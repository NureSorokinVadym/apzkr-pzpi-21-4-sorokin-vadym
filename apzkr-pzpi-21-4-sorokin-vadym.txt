Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система облікових записів відвідувачів спортивної зали.


Студент гр. ПЗПІ-21-4
	__________ Сорокін В. С.
     (підпис)
	Керівник роботи
	__________  доц. Лещинська І. О.
     (підпис)
	

	Роботу захищено «__»_________2024 р.
з оцінкою _____________
	Комісія:
	__________ доц. Лещинська І. О.
     (підпис)
__________ доц. Лещинський І. О.
     (підпис)
__________ ст. викл. Сокорчук І. П.
     (підпис)
	



Харків  2024 р.
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук         Кафедра програмної інженерії                    
Спеціальність 121 – Інженерія програмного забезпечення        
Курс           3                 Семестр                                      6                                       
Навчальна дисципліна Архітектура програмного забезпечення        


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА


        Сорокіну Вадиму Сергійовичу                
1. Тема роботи: «Програмна система облікових записів відвідувачів спортивної зали»        
2. Термін узгодження завдання курсової роботи «24» березня 2024 р.
3. Термін здачі студентом закінченої роботи «10» червня 2024 р.
4. Вихідні дані до проєкту (роботи): В програмній системі передбачити:
5. унікальність, можливість заробітку, актуальність, розповсюдженість, масштабованість, підтримка інтернаціоналізації, локалізація, забезпечення конфіденційності та адміністрування системи, реалізація чотирьох компонентів (Back-end, Front-end, Mobile app, IoT)        
6. Зміст пояснювальної записки (перелік питань, що належить розробити) 
7. вступ, аналіз предметної області, постановка задачі, проєктування програмного проєкту, структура бази даних, розробка програмного проєкту, опис розробленої програмної системи, висновки, перелік посилань, додатки        
8. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) Deployment Diagram, Use Case Diagram, Entity-Relationship Model, Interaction Overview Diagram,  Activity Diagram, State Diagram, Component Diagram, Package Diagram        
________________
КАЛЕНДАРНИЙ ПЛАН






Номер
	Назва етапів курсової роботи
	Строк виконання етапів роботи
	Примітки
	1
	Функціональна специфікація
програмного проєкту
	04.04.24
	

	2
	Проєктування програмного
проєкту
	20.04.24
	

	3
	Кодування програмного проєкту
	20.05.24
	

	4
	Оформлення пояснювальної
записки
	31.05.24
	

	5
	Захист курсової роботи
	08.06.24
	

	

Дата видачі завдання «24» березня 2024 р.




Керівник
	__________  доц. Лещинська І. О.
     (підпис)
	

Завдання прийняв до виконання  


ст. гр. ПЗПІ-21-4
	__________  Сорокін В. С.
     (підпис)
	________________


РЕФЕРАТ




Пояснювальна записка до курсової роботи: 91 с., 30 рис., 2 табл., 4 додатки, 5 джерел. 
FLUTTER, PYTHON, RUST, АДМІНІСТРАТОР, ВІДВІДУВАЧІ, ПОСЛУГА, ПРОГРАМНА СИСТЕМА., СПОРТ, СПОРТЗАЛ, ШІ.
Об’єктом дослідження курсової роботи є ринок надання спортивних послуг, а саме актуальне сьогодні питання мотивації відвідування спортзалу, системи нагород, створення різних спільнот за спортивними інтересами, комунікаціям між відвідувачами, тренерами та адміністраторами спортзали. 
Метою курсової роботи є розробка системи, яка вирішуєш більшість проблем відвідувачів, тренерів та адміністраторів спортзалів, загалом підвищення якості надання послуг та посилення мотивації, і, як наслідок, прибутку залу. 
Методи розробки базуються на технологіях мікросервісної архітектури Docker та Docker Compose з маршрутизатором Nginx для підвищення стабільності системи та з використанням мов програмування Rust, що забезпечує швидкість та стабільність системи, та Python з великою кількістю інструментів для інженерів штучного інтелекту. Системою управління базами даних було обрано PostgreSQL, клієнтська частина базується на технології Flutter з мовою програмування Dart, смарт пристрій розроблено мовою програмування Rust. Для розробки мобільного застосунку було обрано мову програмування Kotlin з UI фреймворком Jetpack Compose.
У результаті роботи здійснено програмну реалізацію системи для облікових записів спортивного залу. Програмна система складається з вебзастосунка, сервера та смарт пристрою. 
ЗМІСТ
ВСТУП        7
1. АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ        8
1.1 Бізнес-вимоги        8
1.1.1 Бізнес можливості        8
1.1.2 Бізнес-цілі та критерії успіху        9
1.1.3 Потреби клієнтів або ринку        10
1.1.4 Бізнес-ризики        12
1.2 КОНЦЕПЦІЯ РІШЕННЯ        13
1.2.1 Окреслення концепції        13
1.2.2 Головна функціональність        14
1.2.3 Припущення та залежності        15
1.3 РАМКИ ТА ОБМЕЖЕННЯ ПРОЄКТУ        16
1.3.1 Рамки первинного випуску        16
1.3.2 Рамки наступних випусків        18
1.3.3 Обмеження та винятки        19
1.4 БІЗНЕС-КОНТЕКСТ        20
1.4.1 Профілі зацікавлених сторін        20
1.4.2 Пріоритети проєкту        21
1.4.3 Робоче середовище        22
2 ПОСТАНОВКА ЗАДАЧІ        24
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ        26
4 ТЕХНОЛОГІЇ ТА АРХІТЕКТУРНІ РІШЕННЯ        29
4.1 Архітектура серверної частини        29
4.2 Архітектура IoT частини        30
4.3 Архітектура клієнтської частини        34
4.4 Архітектура мобільної частини        38
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ        44
5.1 Виклик і завантаження        44
5.2 Призначення та структура        45
5.3 Опис програмної реалізації        46
ВИСНОВКИ        55
Перелік джерел посилання        56
Додаток А Програмний код серверної частини        57
A.1 Код обробки логіки авторизації        57
А.2 Код обробки логіки тренера        57
А.3 Код обробки запитів бази даних        59
A.4 Код обробки запитів до штучного інтелекту        64
Додаток Б Програмний код IoT пристрою        65
Додаток В Програмний код клієнтської частини        68
B.1  Код екрану адміністратора        68
В.2 Код екрану авторизації        75
B.3 Код головного екрану        78
В.4 Код екрану персоналу        82
Додаток Д Програмний код мобільної частини        87
Д.1 Код екранів користувача        87
Д.2 Код класів управління станами екранів        92
Додаток Е Перевірка на академ. доброчесність        102
ВСТУП




У сучасному світі, де люди все більше піклуються про своє здоров'я спортзали стають невіддільною частиною життя багатьох. Проте, як і будь-яка сфера, вони стикаються з певними викликами, які потребують рішень та нових підходів. 
У групових заняттях чи тренуваннях з тренером не завжди враховуються індивідуальні потреби та цілі кожної людини. Це може призвести до неефективності тренувань та незадоволення результатами. Самостійні тренування можуть бути складними, адже складно підтримувати мотивацію та дисципліну без сторонньої допомоги. Це може призвести до того, що люди кидають тренування на півдорозі.
За допомогою штучного інтелекту та машинного навчання можна створювати персоналізовані плани тренувань, які відповідають індивідуальним потребам, цілям та рівню фізичної підготовки. Онлайн та офлайн спільноти людей, які прагнуть до здорового способу життя, можуть мотивувати та підтримувати одне одного, роблячи тренування більш приємними та результативними. Завдяки штучному інтелекту спортзали зможуть надавати більш персоналізований досвід, включаючи рекомендації щодо тренувань, харчування та відновлення. Використання вбудованих пристроїв та інших датчиків дозволить відстежувати дані про здоров'я та фізичну активність у режимі реального часу, надаючи тренерам та користувачам цінну інформацію для оптимізації тренувань.
Головна мета проєкту полягає у створенні ефективної та автоматизованої системи для надання послуг спортивних залів зі штучним інтелектом та інтерактивністю.
   1. АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес-вимоги
1.1.1 Бізнес можливості




Конкурентами у цій галузі спорту є Nike Run Club, Fitbit та Strava.
Nike Run Club (NRC) – це застосунок для бігунів всіх рівнів підготовки: від початківців до марафонців. Серед основних функцій відстеження пробіжок (дистанція, темп, час), GPS-трекінг маршрутів, програми тренувань для бігунів, віртуальні забіги та змагання з друзями. Перевагою є популярність застосунку серед бігунів, пропонує структуровані програми тренувань, велика бігова спільнота.
Fitbit використовують люди з широким спектром цілей щодо здоров'я та фітнесу, включаючи відстеження активності, сну, харчування та ваги. Серед головних функцій відстеження кроків, пройденої відстані, спалених калорій, 9 якості сну, моніторинг пульсу, нагадування про рух. Деякі моделі гаджетів від Fitbit також пропонують GPS-трекінг та інші функції. Перевагою є універсальність застосунку для загального оздоровлення, широкий спектр моделей браслетів та годинників на різний смак, зручний моніторинг різних показників здоров'я. 
Strava – це популярний додаток для відстеження тренувань, який використовують спортсмени різних видів спорту, включаючи біг, їзду на велосипеді, плавання, піші прогулянки, лижі та багато іншого. Є можливість аналізувати свої тренування, ділитися своїми успіхами з друзями та підписниками, знаходити мотивацію у спільнотах. 
Серед переваг є велика кількість видів спорту, детальна аналітика успіхів та велика й активна спільнота. Серед недоліків конкурентів можна назвати обмежену орієнтованість, як от в Nike Run Club тільки на бігунів, або те що деякі функції можуть потребувати підписку, фокус на загальному оздоровленні, а не на інтенсивних тренуваннях. Також варто зазначити що застосунки можуть бути складними для новачків, як до прикладу, Strava. 
Зважаючи на системи конкурентів, можна виділити відмінності та переваги нашого проєкту:
─ ігровий та цікавий формат тренувань;
─ персоналізовані плани тренувань на основі різних видів фітнесу;
─ гейміфікація для підвищення мотивації; 
─ спільнота користувачів для підтримки; 
─ штучний інтелект для адаптації та оптимізації тренувань; 
─ невелика вартість впровадження програмної системи. 
Наша модель монетизації передбачає отримання прибутку завдяки співпраці зі спортзалами, які будуть імплементувати наш застосунок у своїх спортзалах. Також планується преміум підписки з розширеними функціями та реклама партнерських програм




1.1.2 Бізнес-цілі та критерії успіху




БЦ-1: Збільшення числа активних користувачів: протягом двох років досягнути кількості сто тисяч користувачів. 
БЦ-2: Підвищення рівня задоволеності: Проводити періодичні опитування користувачів за якими визначити що задоволення досягло 90%. 
БЦ-3: Збільшити тривалість активного використання до 30 хвилин на день протягом 6 місяців: Це свідчитиме про те, що додаток корисний та цікавий. 
БЦ-4: Збільшити на 15% кількість користувачів, які досягли своїх цілей у фітнесі протягом 1 року: Досягнення цілей показує, що додаток допомагає покращити фізичну форму. 
КУ-1: Забезпечити безперебійну роботу з 99,5% доступністю протягом 1 року: Це критично важливо для позитивного досвіду користувачів. 
КУ-2: Забезпечити безпечне зберігання даних користувачів: Шифрування даних, протоколи безпеки та інші заходи гарантують це. 
КУ-3: Розробити та впровадити нову функцію кожні 6 місяців: Це допоможе зберегти інтерес користувачів та конкурентоспроможність. 
КУ-4: Залучити 100 тренерів для просування протягом 1 року: Це допоможе збільшити обізнаність та залучити нових користувачів. 
КУ-5: Укласти партнерські угоди з 10 виробниками спортивного одягу та обладнання протягом 1 року: Це допоможе отримати доступ до нової аудиторії та запропонувати ексклюзивні пропозиції




1.1.3 Потреби клієнтів або ринку




У нашому продукті існують два основних види користувачів: спортивні зали, їх відвідувачі та тренери. 
Потреби спортивного залу: 
─ збільшення лояльності клієнтів та залучення нових; 
─ покращення якості обслуговування та персоналізація тренувань; 
─ збільшення доходу за нові послуги та підписки; 
─ зниження витрат на управління та маркетинг; 
─ оптимізація роботи тренерів та підвищення їхньої продуктивності.
Потреби відвідувачів спортивних залів: 
─ покращення фізичної форми та досягнення своїх цілей у фітнесі; 
─ збільшення мотивації та прихильності до тренувань; 
─ зручний та цікавий формат тренувань; 
─ доступ до персоналізованих рекомендацій та підтримки; 
─ можливість відстежувати свій прогрес та ділитися ним з друзями; 
─ ефективна комунікація з тренерами та отримання якісної підтримки. 
Потреби тренерів: 
─ ефективні інструменти для планування та проведення тренувань; 
─ можливість відстежувати прогрес своїх клієнтів та мотивувати їх; 
─ зручна комунікація з клієнтами та керівництвом спортивного залу; 
─ доступ до нових методів тренувань та аналітичних даних; 
─ збільшення заробітку завдяки новим послугам та підвищенню якості роботи з клієнтами;




________________
1.1.4 Бізнес-ризики




Ризики:
─ конкуренція на ринку фітнес-додатків, деякі з цих них матимуть більшу кількість користувачів, більші маркетингові бюджети або просунутіші функції; 
─ нездатність задовольнити потреби користувачів, бо фітнес-індустрія постійно розвивається, з появою нових технологій та трендів; 
─ труднощі під час впровадження або невдале впровадження системи у спортивних залах. 
Можливі дії:
─ вдосконалення маркетингових стратегій; 
─ співпраця з фітнес-центрами та тренерами; 
─ консультація з цільовою авдиторією; 
─ проведення пілотних проєктів та тестувань перед повним впровадженням; 
─ надання навчання та підтримки новим користувачам.




________________
1.2 КОНЦЕПЦІЯ РІШЕННЯ
1.2.1 Окреслення концепції




SportChallenger – це інноваційний фітнес-додаток, який робить тренування цікавими, персоналізованими та ефективними, допомагаючи людям досягати своїх цілей у фітнесі та покращувати загальне самопочуття. 
Ми прагнемо стати лідером на ринку фітнес-додатків, пропонуючи користувачам унікальний досвід. Завдяки ігровому формату тренування будуть цікавішими, загалом підвищиться мотивація займатися спортом. Високий рівень персоналізації та штучний інтелект допоможуть підлаштувати застосунок та спростити його використання для кожного, на основі аналізу успіхів давати рекомендації стосовно подальших кроків. Окремим пунктом в нас є взаємодія зі спортзалами, які зможуть додавати свої нагороди, завдання, активності до застосунку у їх закладі. 
Також одним з важливих елементів буде створення спільноти, можливостей для об’єднання, проведення групових занять. Таким чином користувачі будуть мотивувати один одного, отримувати колективний незабутній досвід. Завдяки доступності на різних платформах, спортсмени зможуть комунікувати та тренуватися за будь-яких умов, що також збільшує сфери використання нашого застосунку. 
SportChallenger – це не просто фітнес-додаток, це новий спосіб життя, який допоможе людям досягти своїх цілей у фітнесі, стати більш здоровими та щасливими.


1.2.2 Головна функціональність




ГФ-1: Реєстрація та профілі користувачів: Можливість реєстрації користувачів, створення профілів та керування інформацією про себе. 
ГФ 2: Ігрові тренування: Тренування будуть представлені у вигляді цікавих ігор та викликів, які зроблять їх цікавішими тим, що мотивує. Користувачі зможуть змагатися з друзями та іншими користувачами, отримувати нагороди та відстежувати свій прогрес. 
ГФ-3: Відстеження прогресу: Додаток буде автоматично відстежувати ваші тренування, спалені калорії, пройдену відстань та інші показники. Ви зможете бачити свій прогрес з часом та отримувати мотивацію для досягнення своїх цілей. 
ГФ-4: Безпека даних: Забезпечення високого рівня безпеки та конфіденційності інформації користувачів завдяки шифруванню даних. 
ГФ-5: Штучний інтелект: Штучний інтелект буде використовуватися для адаптації тренувань до вашого прогресу, рівня фізичної підготовки та вподобань. Штучний інтелект також буде надавати вам персоналізовані рекомендації та підтримку.
ГФ-6: Спільнота: SportChallenger буде мати активну спільноту користувачів, які мотивують та підтримують один одного. Ви зможете ділитися своїми досягненнями, досвідом та отримувати поради від інших користувачів.
ГФ-7: Підтримка кількох мов: Можливість використовувати застосунок на різних мовах для зручності користувачів. 
ГФ-8: Доступність на різних платформах: Додаток буде доступний на різних платформах (мобільні пристрої, вебсайт), щоб користувачі могли тренуватися де завгодно і коли завгодно. 
ГФ-9: Підтримка різних видів спорту: SportChallenger буде підтримувати широкий спектр видів спорту, включаючи біг, їзду на велосипеді, плавання, силові тренування, йогу та багато іншого.
ГФ-10: Гнучкість: У спортзалів буде можливість додавати свої налаштування до застосунку.




1.2.3 Припущення та залежності




П-1: Користувачі будуть готові платити за наш продукт. 
П-2: Штучний інтелект буде ефективним. 
П-3: Ми зможемо створити активну спільноту. 
П-4: Ми зможемо налагодити партнерські стосунки з фітнес-центрами та тренерами. 
З-1: Від якості мобільного застосунку, з яким будуть працювати пацієнти, залежить бажання придбання системи іншими лікарнями. 
З-2: Високий рівень безпеки даних підвищить довіру серед пацієнтів та лікарень. 
З-3: Штучний інтелект відіграє ключову роль у персоналізації тренувань, відстеження прогресу та мотивації користувачів.
1.3 РАМКИ ТА ОБМЕЖЕННЯ ПРОЄКТУ
1.3.1 Рамки первинного випуску




Серверна (back-end) частина повинна включати: 
─ реєстрацію та авторизацію користувачів: реалізація системи реєстрування користувачів та сервісу входу з підтримкою різних груп користувачів та прав доступу; 
─ ігрові тренування: різноманітні ігрові тренування, які роблять фізичну активність цікавою та захопливою, нагороджувати за досягнення; 
─ сповіщення користувачів: відправлення сповіщень користувачам про те що вони давно не були в спортзалі, загалом різницю проведеного часу там в порівнянні з минулим тижнем; 
─ захист даних: захист особистих даних користувачів та інформації про пацієнтів; 
─ спільнота: створення активної спільноти користувачів, які мотивують та підтримують один одного, базові функції огляду облікового запису іншого користувача, можливість надіслати повідомлення; 
─ адміністрування системи: управління користувачами системи, управління даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань. 
Smart пристрій частина повинна включати: 
─ збір і відправлення даних: збір і відправлення даних про пульс та тиск спортсмена на серверну частину. 
Сайт (front-end) частина повинна включати: 
─ реєстрація та вхід користувачів: сторінки авторизації та реєстрації; 
─ панель керування: для тренерів можливість управління заняттями та відвідувачами, для спортзалу управління тренерами та відвідувачами, продовження їх абонемента тощо; 
─ панель адміністратора: панель, що дозволяє управління користувачами системи, управління даними системи, створення резервних копій налаштувань та даних, експорт та імпорт даних та налаштувань, управління сертифікатами; 
─ локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу. 
Мобільна частина повинна включати: 
─ реєстрація та вхід користувачів: сторінки авторизації та реєстрації; 
─ перегляд занять: перегляд інформації про тренування; 
─ взаємодія зі спільнотою: можливість написати повідомлення іншим користувачам;
─ рекомендації від системи: перегляд рекомендацій для наступних тренувань; 
─ сповіщення про нагороди: сповіщення про отримання нагороди за заняття; 
─ локалізований та інтернаціоналізований інтерфейс: підтримка української та англійської мови, використання інтернаціональних кодових таблиць символів, локалізоване обчислення та формат дати та часу, підтримка локального та універсального часу, метричних одиниць вимірювання.




1.3.2 Рамки наступних випусків




Серверна (back-end) частина може включати: 
─ аналітика та статистика: реалізація аналітики занять, надання звітів про успіхи для користувачів та адміністраторів;
 ─ відстеження прогресу: автоматичне відстеження тренувань, спалених калорій, пройденої відстані та інших показників; 
─ відгуки про сервіс: можливість користувачам залишати відгуки про наш сервіс; 
─ зберігання історії занять: зберігання історії про усі заняття та вправи;
─ просунутий штучний інтелект: професійніші алгоритми для рекомендацій занять користувачам. 
Smart пристроїв частина може включати: 
─ автоматичне внесення вправ до системи: можливість за допомогою камери аналізувати діяльність людини та вносити це автоматично; 
Сайт (front-end) частина може включати: 
─ просунуте управління заняттями: можливість створення персональних посилань, гнучких графіків, домашніх завдань тощо; 
─ перегляд аналітики та статистики: можливість перегляду аналітики отримання звітів про роботу для користувачів та адміністраторів, даних датчиків протягом визначеного часу; 
─ відгуки про сервіс: можливість користувачам залишати відгуки про наш сервіс; 
─ пошук і фільтрація спортсменів та тренерів: реалізація пошуку та фільтрації за різними критеріями. 
Мобільна частина може включати:
─ аналіз даних: можливість продивлятися графіки, наприклад кількість часу у спортзалі протягом різних днів, середній пульс та навантаження, час, проведений на тренажерах; 
─ перегляд інформації про спільноту: список груп, спільних тренувань, можливість долучитися до них; 
─ перегляд історії занять: можливість перегляду користувачем історії своїх попередніх занять та інформації про них.




 1.3.3 Обмеження та винятки
 


─ залежність від електроенергії: однією з частин системи є smart пристроїв пристрої, що знаходять на тілі та передають дані на сервер. Без електроенергії їх функціонування неможливе; 
─ підключення до мережі Інтернет: для забезпечення зв’язку з системою необхідне підключення до мережі Інтернет. При його відсутності можливе обмеження функціональних можливостей керування й моніторингу; 
─ праця неповної системи: пацієнт може бути перебувати в системі віддалено або без необхідності мати на собі пристрій виміру стану, таким чином система може працювати й без smart пристрій.




1.4 БІЗНЕС-КОНТЕКСТ
1.4.1 Профілі зацікавлених сторін




Таблиця 1.1 – Профілі зацікавлених сторін проєкту
Зацікавлена сторона
	Головна цінність
	Ставлення
	Головний інтерес
	Обмеження
	Користувачі фітнес-центру
	Здоров'я, фізична форма, покращення результатів у спорті
	Зацікавлені в доступі до інноваційних та що мотивує тренувань, відстеженні прогресу та отриманні персоналізованих рекомендацій
	Доступ до функціонального мобільного додатку, вебсайт та Smart пристроїв
	Залежність від електроенергії, підключення до Інтернету, обмеження щодо фізичних можливостей
	Тренери фітнес-центру
	Ефективність тренувань, успіх клієнтів, покращення якості роботи
	Зацікавлені в інструментах для кращого планування та проведення тренувань, моніторингу прогресу клієнтів та надання персоналізованих рекомендацій
	Доступ до функціонального вебсайт та мобільного додатку
	Залежність від електроенергії, підключення до Інтернету, обмеження щодо кількості клієнтів
	Власники фітнес-центру
	Рентабельність інвестицій, задоволення клієнтів, збільшення лояльності
	Зацікавлені в покращенні утримання клієнтів, залученні нових членів клубу та підвищенні прибутку
	Доступ до аналітики даних, звітів про прогрес та рекомендацій щодо покращення бізнесу
	Залежність від електроенергії, підключення до Інтернету, обмеження щодо бюджету
	Розробник проєкту
	Можливість гарно заробити та надалі розширити компанію
	Зацікавленість в успіху проєкту та задоволенні цільової аудиторії
	Заробіток, репутація
	Правові обмеження, нестача досвіду, грошові обмеження, доступ до мережі Інтернет
	Інвестори
	Отримання прибутку
	Зацікавленість в успіху проєкту та прибутку від нього
	Заробіток
	Грошові обмеження
	



1.4.2 Пріоритети проєкту




Таблиця 1.2 – Пріоритети проєкту


Показник
	Виконання (етапи)
	Обмеження (граничні значення)
	Ступінь свободи (допустимий діапазон)
	План робіт
	продукт має бути представлений до 10.06.2024
	

	можливе відхилення від графіка на 1-2 тижні
	Функціональність
	

	

	90% функціоналу має працювати на релізі 1.0
	Якість
	

	

	у випуску 1.0 повинні пройти 100% тестувань
	Персонал
	

	Максимальний розмір команди – один розробник та адміністратор
	Персонал
	Ціна
	

	5000 гривень
	допустиме відхилення на 15%
	



1.4.3 Робоче середовище




Системою зможуть користуватися люди з будь-якої країни. Користувачі повинні мати безперервний доступ до системи. Це буде досягнуто завдяки хмарним сервісам vercel або подібними. 
Також важливо розширити доступність застосунку завдяки локалізації (українська та англійська мови) та інтернаціоналізації (міри ваги, довжини тощо). 
Оскільки застосунок працюватиме в різних країнах, важливо врахувати різницю в часових поясах та представленні часу. 
Дані будуть зберігатися в базі даних PostgreSQL. Доступ до даних здійснюватиметься за допомогою SQL запитів певною частиною застосунку. Також для обміну між контейнерами буде використовуватися база даних Redis.
Для розробки серверної частини буде використано технології Docker та Docker Compose для створення системи контейнерів та взаємодії між ними. Для взаємодії з запитами та надсилання статичних файлів буде використовуватися вебсервером Nginx, для обробки запитів буде використовуватися мова програмування Rust з бібліотекою rocker.rs. Для реалізації штучного інтелекту буде використовуватися мова програмування Python з бібліотеками numpy та подібними. Середовищем розробки буде NeoVim. 
Середовищем розробки IoT частини буде NeoVim, що використовує мову програмування Rust з бібліотекою ureq. Показники будуть симулюватися за допомогою випадкових чисел або підготовлених даних. 
Для розробки клієнтської частини буде використано фреймворк Flutter на мові Dart. Середовищем розробки буде NeoVim. 
Для розробки мобільної частини буде використано технології Jetpack Compose(мова програмування Kotlin). Середовищем розробки буде Android Studio
________________
2 ПОСТАНОВКА ЗАДАЧІ




За результатами попереднього аналізу предметної області, задачею курсової роботи було поставлено створення програмної системи для облікових записів відвідувачів спортивної зали.
База даних повинна включати інформацію про: користувачів, вправи, їх типи, інформацію про тренерів, спеціалізацію тренерів тощо.
Для клієнта має бути реалізований такий функціонал:
   * реєстрація та вхід в систему;
   * перегляд вправ, для тренерів – можливість видавати їх іншим;
   * комунікувати з IoT пристроєм;
   * продивлятися основну інформацію про виконані вправи.
Для адміністратора системи має бути реалізований такий функціонал:
   * реєстрація та вхід в систему;
   * керування користувачами системи;
   * перегляд, додавання, редагування, видалення вправ та їх типів;
   * створення тренерів та інших адміністраторів;
   * перегляд, додавання редагування, видалення клієнтів;
   * експорт даних системи.
Також програмна система повинна підтримувати локалізацію та інтернаціоналізацію, а саме, забезпечувати: підтримку різних кодових таблиць символів, обчислення та формат дати та часу, локальний та універсальний час, метричні одиниці вимірювання, англійську та американську систему мір, порядок сортування текстових значень, різні напрями введення тексту тощо. Детальніше розглянути потреби користувача можна на діаграмі прецедентів (див рис 2.1)
  

Рис. 2.1 – Діаграма прецедентів проєкту
________________
3 ПРОЄКТУВАННЯ БАЗИ ДАНИХ




        Для проєктування бази даних було розроблено ER-модель бази даних (див. рис 3.1). 
  

Рис. 3.1 – ER-модель бази даних
        Вона складається з 10 основних таблиць: користувачі (user_base), персональні тренери (personal), спеціалізації (specification), адміністратори (admin), нагороди (reward), зв'язок користувачів з нагородами (reward_user), типи вправ (exercice_type), вправи (exercice), зв'язок користувачів з вправами (exercice_user) та IoT пристрої користувачів (iot_user).
        У базі даних наявні наступні зв'язки між сутностями:
   * спеціалізації й персональні тренери мають зв'язок один до багатьох, бо одна спеціалізація може бути у декількох персональних тренерів;
   * користувачі й персональні тренери мають зв'язок один до одного, бо один користувач може бути персональним тренером, і кожен персональний тренер є користувачем;
   * користувачі й адміністратори мають зв'язок один до одного, бо один користувач може бути адміністратором, і кожен адміністратор є користувачем;
   * нагороди й користувачі мають зв'язок багато до багатьох, тому було створено проміжну таблицю для зв'язку користувачів з нагородами, бо користувач може мати декілька нагород, і одна нагорода може бути у декількох користувачів;
   * типи вправ і вправи мають зв'язок один до багатьох, бо один тип вправ може мати безліч вправ;
   * вправи й користувачі мають зв'язок багато до багатьох, тому було створено проміжну таблицю для зв'язку користувачів з вправами, бо користувач може виконувати декілька вправ, і одна вправа може бути виконана різними користувачами;
   * користувачі й IoT пристрої мають зв'язок один до багатьох, бо один користувач може мати декілька IoT пристроїв;
   * вправи користувачів і IoT пристрої мають зв'язок один до багатьох, бо один IoT пристрій може бути пов'язаний з наступною вправою користувача.
        Додаткові зв'язки та деталі:
   * Всі основні таблиці мають поля `create_at` і `update_at` для відстеження часу створення та оновлення записів.
   * У таблиці користувачів є унікальне поле `email` для забезпечення унікальності облікових записів.
   * Таблиця персональних тренерів і адміністраторів мають унікальний зовнішній ключ `user_id`, що вказує на їхній зв'язок "один до одного" з таблицею користувачів.
   * У таблиці вправ користувачів є поля для зберігання деталей виконання вправи: тривалість, кількість повторень, вага, пульс та частота серцевих скорочень.
   * Таблиця IoT пристроїв користувачів має поле `next_exercise_id`, що посилається на наступну вправу користувача, яку має виконати пристрій.
        Ця модель даних дозволяє ефективно зберігати та керувати інформацією про користувачів, їхні ролі, вправи, досягнення та IoT пристрої в системі управління фітнес-програмами.


________________


4 ТЕХНОЛОГІЇ ТА АРХІТЕКТУРНІ РІШЕННЯ
        4.1 Архітектура серверної частини




        Для написання серверної частини системи було обрано кілька мов програмування, а саме: Rust для написання клієнтської логіки та обробки даних, Python для написання прототипу штучного інтелекту. 
        Системою керування базами даних було обрано PostgreSQL, до якої з серверної частини будуть надходити запити.
        Для маршрутизації запитів та балансування навантаження було використано Nginx. Загалом сервер використовуватиме технологію Docker та Docker-Compose для створення платформонезалежних контейнерів з можливістю легкого розвертання, що зменшує кількість вимог до сервера на якому буде розгортатися програмне забезпечення.
        Для більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.1). Для демонстрації можливостей сервера було обрано програне забезпечення HttpPie, що має можливість створювати та надсилати запити різних типів, встановлювати вміст запиту та його заголовки.
  

Рис. 4.1 – Діаграма розгортання для серверної частини системи “Sport Changer”




4.2 Архітектура IoT частини




IoT частини розробленої системи взаємодіє з одним типом користувачів, а саме з відвідувачами зали. Прямою взаємодією з користувача відбувається за допомогою монітора, на який виводяться актуальні дані. Пристрій відправляє дані датчиків і в результаті виводить відповідь сервера на екран.
        Взаємодія користувача з IoT частиною системи представлено на діаграмі прецедентів (див. рис. 4.2).
  Рис. 4.2 – Діаграма прецедентів IoT частини системи “Sport Changer”


Таким чином, за допомогою діаграми прецедентів було окреслено функціональні вимоги до IoT частини.
        Для демонстрації функціональних можливостей IoT частини системи, було прийнято рішення реалізувати програмну реалізацію мовою програмування Rust, що максимально наближено до апаратних обмежень IoT пристрою.        
        Для виведення інформації використовується cli інтерфейс. Надсилання даних реалізується за допомогою легкої бібліотеки ureq, самі дані передаються у форматі JSON. Також для довгострокового доступу на сервері існує таблиця з ідентифікаторами, які можна присвоїти до IoT пристрою і мати можливість аналізувати показники датчика. 
        Програма написана з можливістю подальшого розширення та зрозумілості розробником, проте засоби оптимізації Rust дозволяють створювати ефективне програмне забезпечення для пристроїв з обмеженими характеристиками.
Для написання IoT частини системи було обрано мову програмування Rust. Компіляція відбувається за допомогою rustc.
        Для створення запитів використовується бібліотека ureq. Для серіалізації – бібліотека serde. Загалом для створення ефективного середовища було використано tokio, що оптимізував операції вводу-виводу. Більш детальної візуалізації використаних технологій було розроблено діаграму розгортання (див. рис. 4.3).
          
Рис. 4.3 – Діаграма пакетів для IoT частини системи “Sport Changer” 


Для більш детальної візуалізації взаємодії пристрою з користувачами системи було розроблено діаграму взаємодії (див. рис. 4.4).
  

Рис. 4.4 – Діаграма взаємодії для IoT частини системи “Sport Changer” 


Також на основі взаємодії пристрою було побудовано діаграму діяльності, що відображає взаємодію пристрою з сервером (див. рис. 4.5).


  

Рис. 4.5 – Діаграма діяльності для IoT частини системи “Sport Changer”


Таким чином, за допомогою діаграм пакетів, взаємодії та діяльності було визначено основні технології та архітектуру системи.




4.3 Архітектура клієнтської частини




Користувачами системи є 2 типи акторів: тренер та адміністратор. За допомогою клієнтської частини працівнику, клієнту надаються такі можливості, як авторизація та реєстрація, забезпечує відображення інформації відповідно ролі користувача, відображення відвідувачів спортзалу. Адміністратори також використовують вебзастосунок задля адміністрування облікових записів.
Для проєктування клієнтської частини попередньо була розроблена діаграма прецедентів (див. рис. 4.6).


  

Рис. 4.6 – Діаграма прецедентів проєкту


Для проєктування клієнтської частини попередньо була розроблена UML діаграму компонент (див. рис. 4.7). З неї видно, що основним файлом, який містить розмітку і відповідає за відображення усієї необхідної інформації користувачеві, є main.dart. Застосунок було розроблено відповідно до стандартів та правил розробки Flutter застосунків. Також було використано патерн Dependenci Injection для зберігання стану та обміну ним між різними частинами застосунку. Окрім цього для забезпечення гарного досвіду користувача загалом використовувався асинхронним підхід розробки, що забезпечує не блокування застосунку на IO операціях. Фрагмент коду файлу main.dart наведено у додатку A.


  

Рис. 4.7 – UML діаграма компонента проєкт


Для структури програмної системи було виділено пакети, які складають систему. Ці пакети та зв’язки між ними можна побачити на Діаграмі пакетів (рис. 4.8). Було виділено основний пакет рішення, який включає такі пакети, як Domain, в якому зберігаються об’єкти якими обмінюються інші складові системи, в тому числі й мережею. Application, який містить в собі обробку запитів користувача, комунікацію з сервером, зберігання даних під час роботи. Presentation, в якому зберігаються файли, що відповідають за інтерфейс користувача, навігацію між вікнами та інтерналізацію.


  

Рис. 4.8 – UML діаграма пакетів проєкт


Для проєктування клієнтської частини попередньо була розроблена UML діаграму станів (див. рис. 4.9). Початково користувач авторизується, після чого має можливість налаштувати систему під себе та користуватися нею, до прикладу, створює тренерів або завдання.                 
  

Рис. 4.9 – UML діаграма станів проєкт.




4.4 Архітектура мобільної частини 




Користувачами системи є відвідувачі спортзали. За допомогою мобільного додатку, спортсменам надаються такі можливості перегляд власних вправ, прив’язка IoT частини до свого облікового запису, вибір наступної вправи. 
Для проєктування клієнтської частини попередньо була розроблена діаграма прецедентів (див. рис. 4.10).
  

Рис. 4.10 – Діаграма прецедентів
Для надання уявлення про склад програмних компонентів, з яких складається система, було створено діаграму компонентів (рис. 4.11). З неї видно, що основним файлом, який запускає програму і вказує основні налаштування, є MainActivity.kt.


  

Рис. 4.11 – Діаграма компонентів


Файли userScreen.kt та authorizationScreens.kt з пакета presentation.screens відповідають за навігацію та для відображення вмісту. В пакеті Domain.repository.kt знаходиться інтерфейс для взаємодії з репозиторіями даних. Application.repositoryImpl.kt своєю чергою має реалізацію, яка взаємодіє з back end частиною проєкту. Також Domain має пакет dto.kt, в якому зберігаються всі сутності, якими оперує програмна система.
Також пакет Application зберігає в собі реалізації ViewModel, які контролюють стан застосунку, та зберігаються налаштування DI бібліотеки koin.
Кожен файл у пакеті Presentation.Screens зберігаються конкретні відображення (View), що не було прописано для кожного під пакета за для економії місця та зрозумілості на одному прикладі (ui.presentation.userScreen.kt).
В результаті аналізу структури моделі програмної системи було виділено пакети, які складають систему та зовнішні залежності. Ці пакети та зв’язки між ними можна побачити на Діаграмі пакетів (див. рис. 4.12).
Було виділено основний пакет рішення, який включає такі пакети, як Ui, Application, Domain. Також є пакети зовнішніх залежностей Jetpack Compose для побудови інтерфейсу, Koin для обміну даними між об’єктами та Ktor з Kotlinx.Serialize для http/s запитів на backend.
  

Рис. 4.12 – Діаграма пакетів.
Для опису потоку роботи в застосунку, було розроблено діаграму станів (див. рис. 4.13). Початково користувач авторизується, після чого може переглянути свій список занять, прив’язати IoT та обрати наступне заняття.
  

Рис. 4.13 – Діаграма станів.


Детально показано такі стани користувача, як неавторизований та активний, процес переходу від одного стану до іншого. Чітко видно, в яких станах перебуває об’єкт в рамках експлуатації системи.
________________
5 ОПИС ПРОГРАМНОЇ СИСТЕМИ
5.1 Виклик і завантаження




Для використання програмної системи для початку треба розгорнути серверну частину. Для платформонезалежного розгортання використовується програмне забезпечення Docker та Docker Compose. Для початку треба завантажити Docker та розширення до нього Docker Compose на офіційному сайті або ж з репозиторіїв системи у випадку Linux або MacOS. Далі  для запуску сервера необхідно лише завантажити архів з останньою версією серверної частини після чого всередині каталогу за допомогою консольного інтерфейсу запустити команду docker compose up.
Після запуску програмний інтерфейс буде доступний за ip адресою комп’ютера або ж за localhost у разі запуску клієнтської частини локально. 
Для запуску IoT частини у cli інтерфейсі буде достатньо завантажити необхідну скомпільовану версію або завантажити архів з початковим кодом та компілятор мови програмування rust з офіційного сайту, після чого в теці з проєктом прописати cargo build --release для створення виконувальних файлів.
        Клієнтські частини аналогічно можна завантажити вже у придатному до використання або встановлення вигляді або ж самостійно скомпілювати з початкового коду за допомогою Flutter для клієнтської частини та Android Studio для мобільної. Інструменти можна завантажити з офіційних сайтів.


5.2 Призначення та структура




Функції, які може виконувати програма, можна розбити на декілька модулів, а саме:
   * вправи та їх типи;
   * тренери;
   * адміністратори;
   * відвідувачі;
   * виконані та заплановані вправи;
   * авторизація та реєстрація;
   * дані системи.
        Модуль “Вправи ти їх типи” реалізовано операції створення, оновлення, перегляду та видалення вправ, перегляд можливих типів та створення нових. 
        Модуль “Тренери” має в собі функціонал додаванням вправ відвідувачам, переглядом їх досягнень.
        Модуль “Адміністратори” має в собі функціонал призначення нових ролей для користувачів системи, видалення користувачів та редагуванню даних системи. 
        Модуль “Відвідувачі” надає можливість відвідувачам переглядати інформацію про себе, призначати собі IoT пристрої та починати виконання вправ.
        Модуль “Виконані та заплановані вправи” є суміжним модулем для відвідувачів та тренерів, який надає можливість видавати вправи відвідувачам та їм же переглядати їх.
Модуль “Авторизація та реєстрація” надає функції для авторизації в систему та створення нового облікового запису, що дозволяє клієнту створити свій запис у базі даних та надалі входити у систему за допомогою своєї пошти та пароля. Для демонстрації можливостей системи, в системі наявні користувачі admin та personal.
        Модуль “Дані системи” дозволяє експортувати певну інформацію з системи.




5.3 Опис програмної реалізації




При відкритті клієнтського застосунку можна побачити сторінку входу (див. рис. 5.1). 


  

Рис. 5.1 – Екран входу до системи.


Також за допомогою кнопки вгорі з права можна перейти до реєстрації (див. рис. 5.2).


  

Рис. 5.2 – Екран реєстрації у систему.


Після входу в нас з'являється можливість налаштувати клієнтську частину, до прикладу змінити мову, тип сесії, тренер чи адміністратор, експортувати дані, змінити мову, вийти з облікового запису та продивитися інформацію про себе (див. рис. 5.3).
  

Рис. 5.3 – Екран налаштування.
Далі, як адміністратор в нас є можливість керувати іншими користувачами системи та наявними вправами. На екрані керування користувачами можемо побачити список клієнті (див рис. 5.4). 


  

Рис. 5.4 – Екран наявних користувачів.


Далі після вибору потрібного користувача можна перейти до його сторінки на якій з’явиться детальніше інформація про нього та кнопки керування, такі як призначення тренером тощо (див. рис. 5.5).
Також адміністратор може редагувати інформацію про наявні вправи та їх типи (див. рис. 5.6). На екрані також можна побачити кнопку додавання нової вправи знизу праворуч. Загалом також відображається інформація про наявні вправи, їх одиниці виміру. Про кожну вправу можна продивитися детальну інформацію.


  

Рис. 5.5 – Екран налаштування клієнта.
          
Рис. 5.6 – Екран керування вправами.
Екран створення нової вправи дає можливість вказати назву, одиниці виміру та тип вправи (див. рис. 5.7). Також у разі необхідності можна створити власну вправу з власним типом. Результат створення нової вправи нового типу можна побачити на рис. 5.8.


  
        
Рис. 5.7 – Екран створення нової вправи.
          
Рис. 5.8 – Приклад створеної вправи.


Серед функціоналу тренера є можливість перегляду відвідувачів та їх вправи (див. рис. 5.9). Можна побачити чи почав клієнт певну вправу, тип цієї вправи та яка одиниця виміру. Для додавання вправи треба натиснути кнопку знизу праворуч, після чого ми перейдемо на екран, що зображений на рисунку 5.10.


  

Рис. 5.9 – Екран вправ користувача.


  

Рис. 5.10 – Екран створення вправи.
Після створення вправи ми побачимо їх на екрані. Також при початку вправи тренер побачить тривалість. На зображені 5.11 показано яким чином воно відображатиметься та створену вправу.
  

Рис. 5.11 – Перелік вправ, серед яких розпочаті.


Для відвідувачів спортивного залу призначені мобільний застосунок та IoT частина для підвищення інтерактивності під час занять. У мобільному застосунку користувач побачить екран авторизації (див. рис. 5.12). Також якщо користувач вперше у застосунку, він може зареєструватися. 
  

Рис. 5.12 – Екран входу.


Після входу у користувача є можливість продивитися список його вправ з основною інформацією про них (див. рис. 5.13). На ньому ж можна обрати наступну вправу для виконання, після чого ця інформація надійде до IoT пристрою. Прив’язати IoT пристрій можна в екрані налаштування, що зображений на рисунку 5.14. Далі за допомогою IoT вправа почнеться й інформації про неї надійде на сервер.
  

Рис. 5.13 – Екран вправ.
  

Рис. 5.14 – Екран налаштування.


Таким чином, було описано можливості взаємодії користувача з розробленою програмною системою.
________________
ВИСНОВКИ


За результатами виконання роботи було розроблено програмну систему облікових записів відвідувачів спортивної зали.
У процесі роботи було проаналізовано предметну область, спроєктовано базу даних, розроблено архітектуру серверної, IoT та клієнтської частин програмної системи та реалізовано її програмно за допомогою мов програмування Rust, Python, Dart, Kotlin та фреймворків Tokio, Flutter, Koin.
Розроблена програмна система дозволяє користувачам переглядати запропоновані вправи. Вона забезпечує реєстрацію та авторизацію користувачів, керування інформацією про себе інших користувачів в рамках прав доступу. Система забезпечує моніторинг стану відвідувача спортивного залу в реальному часті, отримувати на основі цього поради від штучного інтелекту. Крім того, в системі наявні можливості адміністрування, такі як: керування користувачами системи, керування даними та налаштуваннями системи, експорт даних.
________________
Перелік джерел посилання
   1. Мартін Р. Чистий код: створення і рефакторинг за допомогою AGILE. – ФАБУЛА, 2019. – 416 с.
   2. Klabnik S., Nichols C. The Rust Programming Language. The Rust Programming Language. URL: https://doc.rust-lang.org/stable/book/ (дата звернення: 04.06.2024).
   3. Docker Compose overview. Docker Documentation. URL: https://docs.docker.com/compose/ (date of access: 04.06.2024).
   4. Nginx documentation. Nginx news. URL: https://nginx.org/en/docs/ (date of access: 04.06.2024).
   5. Flutter documentation. Docs | Flutter. URL: https://docs.flutter.dev/ (date of access: 04.06.2024).
   6. Посилання на демонстрацію: https://youtu.be/YV8muxhDzlM?si=ZsuqqJMX40nQN5k3
________________
Додаток А Програмний код серверної частини
A.1 Код обробки логіки авторизації
     1        use hmac::{Hmac, Mac};
     2        use jwt::{SignWithKey, VerifyWithKey};
     3        use pwhash::bcrypt;
     4        use sha2::Sha256;
     5        use std::collections::BTreeMap;
       
     6        const SECRET: &[u8; 10] = b"secret_key";
       
     7        fn get_key() -> Hmac<Sha256> {
     8            Hmac::new_from_slice(SECRET).expect("HMAC can take key of any size")
     9        }
       
    10        pub fn create_token(user_id: i32) -> String {
    11            let mut claims = BTreeMap::new();
    12            claims.insert("user_id", user_id.to_string());
    13            claims.sign_with_key(&get_key()).unwrap()
    14        }
       
    15        pub fn validate_token(token: &str) -> Result<i32, String> {
    16            let claims: BTreeMap<String, String> = token.verify_with_key(&get_key()).unwrap();
    17            let user_id = claims.get("user_id").ok_or("User id not found")?;
    18            Ok(user_id.parse().map_err(|_| "User id is not a number")?)
    19        }
       
    20        pub fn hash_password(password: &str) -> String {
    21            bcrypt::hash(password).expect("Password hash error")
    22        }
       
    23        pub fn verify_password(password: &str, hash: &str) -> bool {
    24            bcrypt::verify(password, hash)
    25        }


  А.2 Код обробки логіки тренера
     1        use super::authentication as auth;
     2        use crate::domain::dto::*;
     3        use crate::infrastructure::postgresql::{admin_repo, authentication as auth_repo, personal_repo};
       
     4        use std::collections::HashMap;
       
     5        use sqlx::PgPool;
       
     6        pub async fn create_personal(db: &PgPool, personal: &Personal) -> Result<i32, String> {
     7            auth_repo::create_personal(db, personal.user_id, personal.specification_id)
     8                .await
     9                .unwrap();
    10            Ok(10)
    11        }
       
    12        pub async fn get_specifications(db: &PgPool) -> HashMap<i32, String> {
    13            personal_repo::get_specifications(db).await.unwrap()
    14        }
       
    15        pub async fn create_specification(
    16            db: &PgPool,
    17            token: &str,
    18            specification: &Specification,
    19        ) -> Result<i32, String> {
    20            let user_id = auth::validate_token(token)?;
    21            let user_access_level = admin_repo::get_admin_access_level(db, user_id).await;
    22            if user_access_level.unwrap_or(0) < 5 {
    23                return Err("User access level is not enough".to_string());
    24            }
    25            personal_repo::create_specification(db, &specification)
    26                .await
    27                .unwrap();
    28            Ok(10)
    29        }
       
    30        pub async fn get_clients(db: &PgPool, token: &str) -> Vec<User> {
    31            let user_id = auth::validate_token(token).unwrap();
       
    32            personal_repo::get_client_from_personal(db, user_id)
    33                .await
    34                .unwrap()
    35        }
       
    36        pub async fn get_client_exercises(db: &PgPool, token: &str, user_id: i32) -> Vec<ExerciseUser> {
    37            let personal_user_id = auth::validate_token(token).unwrap();
    38            let is_personal = auth_repo::is_personal(db, personal_user_id).await.unwrap();
    39            if !is_personal {
    40                return vec![];
    41            }
    42            personal_repo::get_client_exercises(db, user_id)
    43                .await
    44                .unwrap()
    45        }
       
    46        pub async fn get_exercises_list(db: &PgPool) -> Vec<Exercise> {
    47            personal_repo::get_exercises_list(db).await.unwrap()
    48        }
       
    49        pub async fn add_exercise(db: &PgPool, token: &str, pair: &UserExercisePair) -> Result<(), String> {
    50            let personal_user_id = auth::validate_token(token).unwrap();
    51            let is_personal = auth_repo::is_personal(db, personal_user_id).await.unwrap();
    52            if !is_personal {
    53                return Err("User is not personal".to_string());
    54            }
    55            personal_repo::add_exercise(db, pair).await.unwrap();
    56            Ok(())
    57        }
       
    58        pub async fn get_exercise_types(db: &PgPool) -> HashMap<i32, String> {
    59            personal_repo::get_exercise_types(db).await.unwrap()
    60        }
А.3 Код обробки запитів бази даних


     1        use crate::domain::dto::*;
     2        use sqlx::types::time::PrimitiveDateTime;
     3        use sqlx::PgPool;
     4        use sqlx::Row;
     5        use std::collections::HashMap;
       
     6        pub async fn create_specification(
     7            db: &PgPool,
     8            specification: &Specification,
     9        ) -> Result<i32, sqlx::Error> {
    10            let _result = sqlx::query("insert into specification (name) values ($1)")
    11                .bind(&specification.name)
    12                .execute(db)
    13                .await?;
    14            Ok(33)
    15        }
       
    16        pub async fn get_specifications(db: &PgPool) -> Result<HashMap<i32, String>, sqlx::Error> {
    17            let rows: Vec<(i32, String)> = sqlx::query_as("select id, name from specification")
    18                .fetch_all(db)
    19                .await?;
    20            Ok(rows.into_iter().collect())
    21        }
    22        pub async fn give_reward(db: &PgPool, user_id: i32, reward: i32) -> Result<(), sqlx::Error> {
    23            let _result = sqlx::query("insert into reward_user (reward_id, user_id) values ($1, $2)")
    24                .bind(reward)
    25                .bind(user_id)
    26                .execute(db)
    27                .await?;
    28            Ok(())
    29        }
       
    30        pub async fn create_exercice(db: &PgPool, exercise: &Exercise) -> Result<(), sqlx::Error> {
    31            let _result = sqlx::query(
    32                "insert into exercice (name, measurement, exercice_type_id) values ($1, $2, $3)",
    33            )
    34            .bind(&exercise.name)
    35            .bind(&exercise.measurement)
    36            .bind(exercise.exercice_type_id)
    37            .execute(db)
    38            .await?;
    39            Ok(())
    40        }
    41        pub async fn create_exercice_type(
    42            db: &PgPool,
    43            exercise_type: &ExerciceType,
    44        ) -> Result<i32, sqlx::Error> {
    45            let id: Option<(i32,)> = sqlx::query_as("select id from exercice_type where name = $1")
    46                .bind(&exercise_type.name)
    47                .fetch_optional(db)
    48                .await?;
    49            if id.is_some() {
    50                return Ok(id.unwrap().0);
    51            }
       
    52            let id: (i32,) = sqlx::query_as("insert into exercice_type (name) values ($1) returning id")
    53                .bind(&exercise_type.name)
    54                .fetch_one(db)
    55                .await?;
    56            Ok(id.0)
    57        }
    58        pub async fn create_reward(db: &PgPool, reward: &Reward) -> Result<(), sqlx::Error> {
    59            let _result = sqlx::query("insert into reward (name, condition) values ($1, $2)")
    60                .bind(&reward.name)
    61                .bind(&reward.condition)
    62                .execute(db)
    63                .await?;
    64            Ok(())
    65        }
    66        pub async fn give_exercice(
    67            db: &PgPool,
    68            user_exercise: &UserExercisePair,
    69        ) -> Result<i32, sqlx::Error> {
    70            let id: (i32,) = sqlx::query_as(
    71                "insert into exercice_user (user_id, exercice_id) values ($1, $2) returning id",
    72            )
    73            .bind(user_exercise.user_id.unwrap_or(0))
    74            .bind(user_exercise.exercise_id)
    75            .fetch_one(db)
    76            .await?;
    77            Ok(id.0)
    78        }
       
    79        pub async fn get_client_from_personal(
    80            db: &PgPool,
    81            _personal_id: i32,
    82        ) -> Result<Vec<User>, sqlx::Error> {
    83            let clients: Vec<(i32, String, Option<String>, String)> =
    84                sqlx::query_as("select id, name, surname, email from user_base")
    85                    .fetch_all(db)
    86                    .await?;
       
    87            Ok(clients.iter().map(User::from).collect())
    88        }
       
    89        pub async fn get_client_exercises(
    90            db: &PgPool,
    91            user_id: i32,
    92        ) -> Result<Vec<ExerciseUser>, sqlx::Error> {
    93            let exercises = sqlx::query(
    94                "select exercice_user.id as ex_us_id, exercice_user.duration, exercice_user.weight, exercice_user.number, exercice_user.pulse,
    95                exercice_user.create_at as ex_us_create_at, exercice.id as ex_id, exercice.name, exercice.measurement, exercice.exercice_type_id, exercice.create_at as ex_create_at from exercice_user
    96                join exercice on exercice_user.exercice_id = exercice.id
    97                where exercice_user.user_id = $1",
    98            )
    99            .bind(user_id)
   100            .fetch_all(db)
   101            .await?;
       
   102            Ok(exercises
   103                .iter()
   104                .map(|e| {
   105                    let ex_us_ct: PrimitiveDateTime = e.get("ex_us_create_at");
   106                    let ex_ct: PrimitiveDateTime = e.get("ex_create_at");
   107                    ExerciseUser {
   108                        id: e.get("ex_us_id"),
   109                        duration: e.get("duration"),
   110                        weight: e.get("weight"),
   111                        number: e.get("number"),
   112                        pulse: e.get("pulse"),
   113                        create_at: ex_us_ct.to_string(),
   114                        exercise: Exercise {
   115                            id: e.get("ex_id"),
   116                            name: e.get("name"),
   117                            measurement: e.get("measurement"),
   118                            exercice_type_id: e.get("exercice_type_id"),
   119                            create_at: Some(ex_ct.to_string()),
   120                        },
   121                    }
   122                })
   123                .collect())
   124        }
       
   125        pub async fn get_exercises_list(db: &PgPool) -> Result<Vec<Exercise>, sqlx::Error> {
   126            let exercises: Vec<(i32, String, String, i32, PrimitiveDateTime)> =
   127                sqlx::query_as("select id, name, measurement, exercice_type_id, create_at from exercice")
   128                    .fetch_all(db)
   129                    .await?;
   130            Ok(exercises
   131                .iter()
   132                .map(|e| Exercise {
   133                    id: Some(e.0),
   134                    name: e.1.clone(),
   135                    measurement: e.2.clone(),
   136                    exercice_type_id: e.3,
   137                    create_at: Some(e.4.to_string()),
   138                })
   139                .collect())
   140        }
       
   141        pub async fn add_exercise(db: &PgPool, pair: &UserExercisePair) -> Result<(), sqlx::Error> {
   142            let result = sqlx::query("insert into exercice_user (user_id, exercice_id) values ($1, $2)")
   143                .bind(pair.user_id.unwrap_or(1))
   144                .bind(pair.exercise_id)
   145                .execute(db)
   146                .await;
   147            print!("{:?}", result);
       
   148            Ok(())
   149        }
       
   150        pub async fn get_exercise_types(db: &PgPool) -> Result<HashMap<i32, String>, sqlx::Error> {
   151            let types: Vec<(i32, String)> = sqlx::query_as("select id, name from exercice_type")
   152                .fetch_all(db)
   153                .await?;
   154            Ok(types.into_iter().collect())
   155        }
       
   156        pub async fn set_exercise_task(
   157            db: &PgPool,
   158            user_id: i32,
   159            exercise_user_id: i32,
   160        ) -> Result<(), sqlx::Error> {
   161            sqlx::query("update iot_user set next_exercise_id = $1 where user_id = $2")
   162                .bind(exercise_user_id)
   163                .bind(user_id)
   164                .execute(db)
   165                .await?;
   166            Ok(())
   167        }


A.4 Код обробки запитів до штучного інтелекту 
     1        from datetime import datetime
       
     2        import jwt
     3        import numpy as np
       
     4        from . import infostructure as db
     5        from .domain import (DefaultResponse, ExerciseDuration, IotData, Settings,
     6                             UserExercise, exercises)
       
       
     7        async def get_settings(iot_id: int) -> Settings:
     8            user_id = await db.get_user_id(iot_id)
     9            print(f"user_id: {user_id}")
    10            return Settings(
    11                token=jwt.encode({"user_id": user_id}, "secret_key", algorithm="HS256")
    12            )
       
       
    13        async def start_exercise(user_id: int) -> DefaultResponse:
    14            if user_id in exercises:
    15                return DefaultResponse(message="Exercise already started")
       
    16            exercises[user_id] = UserExercise(id=user_id, user_id=user_id)
    17            return DefaultResponse(message="Exercise started")
       
       
    18        async def predict(user_id: int, iot_data: IotData) -> DefaultResponse:
    19            exercise = exercises[user_id]
    20            pulse = iot_data.pulse
    21            temperature = iot_data.temperature
    22            duration = (datetime.now() - exercise.start_time).seconds
    23            prediction = predictor.predict(temperature, pulse, duration)
    24            return DefaultResponse(message=f"Scope: {prediction}")
       
       
    25        async def end_exercise(user_id: int, iot_id: int) -> DefaultResponse:
    26            exercise = exercises.pop(user_id)
    27            duration = (datetime.now() - exercise.start_time).seconds
    28            exercise_id = await db.get_exercise(iot_id)
    29            await db.save_duration(exercise_id, duration)
    30            return DefaultResponse(message=f"Duration: {duration}")
       
       
    31        async def make_light_prediction(iot_data: IotData) -> float:
    32            return predictor.predict(iot_data.temperature, iot_data.pulse, 3)
       
       
    33        class Predictor:
    34            def __init__(self):
    35                temperatures = np.array([36, 36, 36, 37, 35])
    36                pulses = np.array([70, 75, 80, 90, 95])
    37                durations = np.array([30, 45, 60, 75, 90])
    38                scope = np.array([0.8, 0.7, 0.6, 0.4, 0.2])
       
    39                X = np.column_stack((temperatures, pulses, durations))
       
    40                y = scope.reshape(-1, 1)
       
    41                X_T = X.T
    42                X_T_X_inv = np.linalg.pinv(X_T @ X)
    43                self.weights = X_T_X_inv @ X_T @ y
       
    44            def predict(self, temp, pulse, duration) -> float:
    45                features = np.array([temp, pulse, duration])
    46                prediction = (
    47                    self.weights[0] * features[0]
    48                    + self.weights[1] * features[1]
    49                    + self.weights[2] * features[2]
    50                )
    51                return prediction
       
       
    52        predictor = Predictor()












Додаток Б Програмний код IoT пристрою
     1        use crate::domain as dto;
     2        use crate::infostructure::http;
       
     3        pub async fn registration() -> dto::DefaultResponse {
     4            http::registration().await;
     5            dto::DefaultResponse::new(String::from("Registration success"))
     6        }
       
     7        pub async fn get_token() -> dto::Settings {
     8            http::get_token().await
     9        }
       
    10        pub async fn start_exercise(settings: &dto::Settings) -> dto::DefaultResponse {
    11            http::start_exercise(settings).await
    12        }
       
    13        pub async fn get_predict(
    14            data: &mut dto::Sensors,
    15            settings: &dto::Settings,
    16        ) -> dto::DefaultResponse {
    17            data.update();
    18            http::get_predict(data, settings).await
    19        }
       
    20        pub async fn end_exercise(settings: &dto::Settings) -> dto::DefaultResponse {
    21            http::end_exercise(settings).await
    22        }
    23        use rand::{thread_rng, Rng};
    24        use serde::{Deserialize, Serialize};
       
    25        #[derive(Deserialize)]
    26        pub struct DefaultResponse {
    27            pub id: Option<i32>,
    28            pub message: String,
    29        }
       
    30        impl DefaultResponse {
    31            pub fn new(message: String) -> Self {
    32                Self { id: None, message }
    33            }
    34        }
       
    35        #[derive(Serialize)]
    36        pub struct ExerciseDuration {
    37            pub duration: i32,
    38        }
       
    39        #[derive(Deserialize)]
    40        pub struct Settings {
    41            pub token: String,
    42        }
       
    43        impl Settings {
    44            pub fn new(token: String) -> Self {
    45                Self { token }
    46            }
    47        }
       
    48        #[derive(Serialize)]
    49        pub struct Sensors {
    50            pub pulse: i32,
    51            pub temperature: f32,
    52        }
       
    53        // Місце для математичних розрахунків
    54        impl Sensors {
    55            pub fn new() -> Self {
    56                Self {
    57                    pulse: 100,
    58                    temperature: 36.6,
    59                }
    60            }
       
    61            pub fn update(&mut self) {
    62                self.pulse += thread_rng().gen_range(-2..3);
    63                self.temperature += thread_rng().gen_range(-0.05..0.1);
    64            }
    65        }
    66        pub mod http {
    67            use crate::domain::{DefaultResponse, Sensors, Settings};
    68            use ureq::{patch, post};
       
    69            const URL: &'static str = "http://localhost";
    70            pub const ID: i32 = 1_000_999;
       
    71            pub async fn registration() {
    72                ureq::post(&format!("{}/api/user/register_iot", URL))
    73                    .send_json(ureq::json!({
    74                        "iot_id": ID,
    75                    }))
    76                    .unwrap();
    77            }
       
    78            pub async fn get_token() -> Settings {
    79                ureq::get(&format!("{}/ai/setting", URL))
    80                    .set("Authorization", ID.to_string().as_str())
    81                    .call()
    82                    .unwrap()
    83                    .into_json()
    84                    .unwrap()
    85            }
       
    86            pub async fn start_exercise(settings: &Settings) -> DefaultResponse {
    87                patch(&format!("{}/ai/start_exercise", URL))
    88                    .set("Authorization", settings.token.as_str())
    89                    .call()
    90                    .unwrap()
    91                    .into_json()
    92                    .unwrap()
    93            }
       
    94            pub async fn get_predict(data: &Sensors, settings: &Settings) -> DefaultResponse {
    95                post(&format!("{}/ai/predict", URL))
    96                    .set("Authorization", settings.token.as_str())
    97                    .send_json(data)
    98                    .unwrap()
    99                    .into_json()
   100                    .unwrap()
   101            }
       
   102            pub async fn end_exercise(settings: &Settings) -> DefaultResponse {
   103                patch(&format!("{}/ai/end_exercise", URL))
   104                    .set("Authorization", settings.token.as_str())
   105                    .send_json(ureq::json!({
   106                    "iot_id": ID,
   107                    }))
   108                    .unwrap()
   109                    .into_json()
   110                    .unwrap()
   111            }
   112        }




Додаток В Програмний код клієнтської частини
B.1  Код екрану адміністратора
     1        import "package:flutter/material.dart";
     2        import "package:hooks_riverpod/hooks_riverpod.dart";
     3        import 'package:go_router/go_router.dart';
     4        import 'package:functional_widget_annotation/functional_widget_annotation.dart';
     5        import 'package:sport_changer/application/controllers/personal.dart';
     6        import 'package:flutter_hooks/flutter_hooks.dart';
     7        import 'package:sport_changer/application/controllers/admin.dart';
     8        import 'package:sport_changer/presentation/router/routes.dart';
     9        import 'package:sport_changer/domain/admin.dart';
    10        import 'package:sport_changer/domain/personal.dart';
    11        import 'package:gap/gap.dart';
    12        import 'package:sport_changer/application/controllers/auth.dart';
    13        part 'admin.g.dart';
       
    14        @hcwidget
    15        Widget adminMainScreen(BuildContext context, WidgetRef ref) {
    16          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    17          return Scaffold(
    18            appBar: AppBar(
    19              title: Text(lang["admin_screen"] ?? "Admin Screen"),
    20            ),
    21            body: Center(
    22              child: Row(
    23                mainAxisAlignment: MainAxisAlignment.center,
    24                children: [
    25                  ElevatedButton(
    26                    onPressed: () {
    27                      context.push(Routes.adminClients.url);
    28                    },
    29                    child: Text(lang["client"] ?? "Clients"),
    30                  ),
    31                  const Gap(32),
    32                  ElevatedButton(
    33                    onPressed: () {
    34                      context.push(Routes.adminExercises.url);
    35                    },
    36                    child: Text(lang["exercise"] ?? "Exercises"),
    37                  ),
    38                ],
    39              ),
    40            ),
    41          );
    42        }
       
    43        @hcwidget
    44        Widget adminClientsScreen(BuildContext context, WidgetRef ref) {
    45          final clients = ref.watch(clientControllerProvider);
    46          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    47          return Scaffold(
    48            appBar: AppBar(
    49              title: Text(lang["admin_exercise_screen"] ?? "Admin Exercise Screen"),
    50            ),
    51            floatingActionButton: FloatingActionButton(
    52              onPressed: () {
    53                ref.read(clientControllerProvider.notifier).updateClients();
    54              },
    55              child: const Icon(Icons.refresh),
    56            ),
    57            body: Padding(
    58              padding: const EdgeInsets.all(16),
    59              child: Center(
    60                child: clients.when(
    61                  data: (clients) => ListView.builder(
    62                    itemCount: clients.length,
    63                    itemBuilder: (context, index) {
    64                      final client = clients[index];
    65                      return ListTile(
    66                        title: Text(client.name ?? "No name"),
    67                        subtitle: Text(client.surname ?? "No surname"),
    68                        onTap: () {
    69                          showDialog(
    70                            context: context,
    71                            builder: (context) {
    72                              return AlertDialog(
    73                                title: Text("Client ID: ${client.id}"),
    74                                content: Column(
    75                                  children: [
    76                                    Text("Name: ${client.name}"),
    77                                    Text("Surname: ${client.surname}"),
    78                                    Text("Email: ${client.email}"),
    79                                  ],
    80                                ),
    81                                actions: [
    82                                  TextButton(
    83                                      onPressed: () {
    84                                        ref.read(createPersonalProvider(
    85                                            personal: Personal(
    86                                                user_id: client.id,
    87                                                specificationId: 1)));
    88                                      },
    89                                      child: const Text("Give personal")),
    90                                  TextButton(
    91                                      onPressed: () {},
    92                                      child: const Text("Give admin")),
    93                                  TextButton(
    94                                      onPressed: () {}, child: const Text("Delete")),
    95                                  TextButton(
    96                                    onPressed: context.pop,
    97                                    child: const Text("Close"),
    98                                  ),
    99                                ],
   100                              );
   101                            },
   102                          );
   103                        },
   104                      );
   105                    },
   106                  ),
   107                  loading: () => const CircularProgressIndicator(),
   108                  error: (error, stack) => Text("Error: $error"),
   109                ),
   110              ),
   111            ),
   112          );
   113        }
       
   114        @hcwidget
   115        Widget adminExercisesScreen(BuildContext context, WidgetRef ref) {
   116          final exercisesWather = ref.watch(getExercisesProvider);
   117          final exerciseTypes = ref.watch(getExerciseTypesProvider);
   118          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
   119          return Scaffold(
   120            appBar: AppBar(
   121              title: Text(lang["admin_exercise_screen"] ?? "Admin Exercise Screen"),
   122            ),
   123            floatingActionButton: FloatingActionButton(
   124              onPressed: () {
   125                context.push(Routes.adminCreateExercises.url);
   126              },
   127              child: const Icon(Icons.add),
   128            ),
   129            body: Center(
   130              child: exercisesWather.when(
   131                data: (exercises) => ListView.separated(
   132                  shrinkWrap: true,
   133                  itemCount: exercises.length,
   134                  separatorBuilder: (context, index) => const Divider(),
   135                  itemBuilder: (context, index) {
   136                    final exercise = exercises[index];
   137                    return ListTile(
   138                      title: Text(exercise.name),
   139                      subtitle: Text(exercise.measurement ?? "No measurement"),
   140                      onTap: () {
   141                        showDialog(
   142                          context: context,
   143                          builder: (context) {
   144                            return AlertDialog(
   145                              title: Text("Exercise ID: ${exercise.id}"),
   146                              content: Column(
   147                                children: [
   148                                  Text("Name: ${exercise.name}"),
   149                                  Text("Measurement: ${exercise.measurement}"),
   150                                  exerciseTypes.when(
   151                                    loading: () => const CircularProgressIndicator(),
   152                                    error: (error, stack) => Text("Error: $error"),
   153                                    data: (data) {
   154                                      final type = data[exercise.exerciseTypeId];
   155                                      return Text("Type: $type");
   156                                    },
   157                                  )
   158                                ],
   159                              ),
   160                              actions: [
   161                                TextButton(
   162                                  onPressed: () {
   163                                    context.pop();
   164                                  },
   165                                  child: const Text("Close"),
   166                                ),
   167                                TextButton(
   168                                  onPressed: () {
   169                                    ref.read(deleteExerciseProvider(id: exercise.id!));
   170                                    ref
   171                                        .read(getExercisesProvider.notifier)
   172                                        .updateExercises();
       
   173                                    context.pop();
   174                                  },
   175                                  child: const Text("Delete"),
   176                                ),
   177                              ],
   178                            );
   179                          },
   180                        );
   181                      },
   182                    );
   183                  },
   184                ),
   185                loading: () => const CircularProgressIndicator(),
   186                error: (error, stack) => Text("Error: $error"),
   187              ),
   188            ),
   189          );
   190        }
       
   191        @hcwidget
   192        Widget createExercise(BuildContext context, WidgetRef ref) {
   193          final nameController = useTextEditingController();
   194          final measurementController = useTextEditingController();
   195          final typeController = useTextEditingController();
   196          final exerciseTypes = ref.watch(getExerciseTypesProvider);
   197          final selectedId = useState<int?>(null);
       
   198          return Scaffold(
   199            appBar: AppBar(
   200              title: const Text("Create Exercise"),
   201            ),
   202            body: Center(
   203                child: Padding(
   204              padding: const EdgeInsets.symmetric(horizontal: 16),
   205              child: Column(
   206                children: [
   207                  TextField(
   208                    decoration: const InputDecoration(labelText: "Name"),
   209                    controller: nameController,
   210                  ),
   211                  TextField(
   212                    decoration: const InputDecoration(labelText: "Measurement"),
   213                    controller: measurementController,
   214                  ),
   215                  exerciseTypes.when(
   216                    loading: () => const CircularProgressIndicator(),
   217                    error: (error, stack) => Text("Error: $error"),
   218                    data: (data) => DropdownMenu<int>(
   219                        controller: typeController,
   220                        onSelected: (value) {
   221                          selectedId.value = value;
   222                        },
   223                        dropdownMenuEntries: data.entries.map((e) {
   224                          return DropdownMenuEntry(
   225                            value: e.key,
   226                            label: e.value,
   227                          );
   228                        }).toList()),
   229                  ),
   230                  exerciseTypes.when(
   231                    loading: () => const CircularProgressIndicator(),
   232                    error: (error, stack) => Text("Error: $error"),
   233                    data: (data) => TextButton(
   234                      onPressed: () {
   235                        if (nameController.text.isEmpty ||
   236                            measurementController.text.isEmpty ||
   237                            typeController.text.isEmpty) {
   238                          return;
   239                        }
   240                        if (selectedId.value != null &&
   241                            data.containsValue(typeController.text)) {
   242                          ref.read(createExerciseProvider(
   243                              E: Exercise(
   244                                  name: nameController.text,
   245                                  measurement: measurementController.text,
   246                                  exerciseTypeId: selectedId.value)));
   247                        } else {
   248                          ref.read(createExerciseProvider(
   249                              E: Exercise(
   250                                  name: nameController.text,
   251                                  measurement: measurementController.text),
   252                              type: typeController.text));
   253                        }
   254                      },
   255                      child: const Text("Create"),
   256                    ),
   257                  ),
   258                ],
   259              ),
   260            )),
   261          );
   262        }


В.2 Код екрану авторизації
     1        import "package:flutter/material.dart";
     2        import "package:hooks_riverpod/hooks_riverpod.dart";
     3        import 'package:flutter_hooks/flutter_hooks.dart';
     4        import "package:go_router/go_router.dart";
     5        import 'package:functional_widget_annotation/functional_widget_annotation.dart';
     6        import 'package:sport_changer/presentation/router/routes.dart';
       
     7        import 'package:sport_changer/application/controllers/auth.dart';
     8        import 'package:sport_changer/application/server_setting.dart';
       
     9        part 'authentication.g.dart';
       
    10        @hcwidget
    11        Widget sighUpScreen(BuildContext context, WidgetRef ref) {
    12          final emailController = useTextEditingController();
    13          final passwordController = useTextEditingController();
    14          final nameController = useTextEditingController();
    15          final surnameController = useTextEditingController();
       
    16          return Scaffold(
    17              appBar: AppBar(
    18                title: const Text("Sigh up"),
    19                actions: [
    20                  IconButton(
    21                      onPressed: () => context.go(Routes.login.url),
    22                      icon: const Icon(Icons.login))
    23                ],
    24              ),
    25              body: Padding(
    26                padding: const EdgeInsets.all(16),
    27                child: Center(
    28                  child: Column(
    29                    children: [
    30                      TextField(
    31                        controller: emailController,
    32                        decoration: const InputDecoration(labelText: "Email"),
    33                      ),
    34                      TextField(
    35                        controller: passwordController,
    36                        decoration: const InputDecoration(labelText: "Password"),
    37                      ),
    38                      TextField(
    39                        controller: nameController,
    40                        decoration: const InputDecoration(labelText: "Name"),
    41                      ),
    42                      TextField(
    43                        controller: surnameController,
    44                        decoration: const InputDecoration(labelText: "Surname"),
    45                      ),
    46                      TextButton(
    47                          child: const Text("Log up"),
    48                          onPressed: () => ref
    49                              .read(authInfoControlerProvider.notifier)
    50                              .requestLogup(
    51                                  emailController.text,
    52                                  passwordController.text,
    53                                  nameController.text,
    54                                  surnameController.text)),
    55                      const Spacer(),
    56                      const ChangeUrlSetting(),
    57                    ],
    58                  ),
    59                ),
    60              ));
    61        }
       
    62        @hcwidget
    63        Widget logInScreen(BuildContext context, WidgetRef ref) {
    64          final emailController = useTextEditingController();
    65          final passwordController = useTextEditingController();
       
    66          return Scaffold(
    67              appBar: AppBar(
    68                title: const Text("Login"),
    69                actions: [
    70                  IconButton(
    71                      onPressed: () => context.go(Routes.sighup.url),
    72                      icon: const Icon(Icons.app_registration))
    73                ],
    74              ),
    75              body: Padding(
    76                padding: const EdgeInsets.all(16),
    77                child: Center(
    78                  child: Column(
    79                    children: [
    80                      TextField(
    81                        controller: emailController,
    82                        decoration: const InputDecoration(labelText: "Email"),
    83                      ),
    84                      TextField(
    85                        controller: passwordController,
    86                        decoration: const InputDecoration(labelText: "Password"),
    87                      ),
    88                      TextButton(
    89                          child: const Text("Log in"),
    90                          onPressed: () => ref
    91                              .read(authInfoControlerProvider.notifier)
    92                              .requestLogin(
    93                                  emailController.text, passwordController.text)),
    94                      const Spacer(),
    95                      const ChangeUrlSetting()
    96                    ],
    97                  ),
    98                ),
    99              ));
   100        }
       
   101        @hcwidget
   102        Widget changeUrlSetting(BuildContext context, WidgetRef ref) {
   103          final urlController = useTextEditingController();
   104          urlController.text = ref.watch(serverSettingProvider).url;
       
   105          return Column(
   106            children: [
   107              TextField(
   108                controller: urlController,
   109                decoration: const InputDecoration(labelText: "Url"),
   110              ),
   111              TextButton(
   112                  child: const Text("Change"),
   113                  onPressed: () => ref
   114                      .read(serverSettingProvider.notifier)
   115                      .changeUrl(urlController.text)),
   116            ],
   117          );
   118        }


B.3 Код головного екрану 
     1        import "package:flutter/material.dart";
     2        import "package:hooks_riverpod/hooks_riverpod.dart";
     3        import 'package:flutter_hooks/flutter_hooks.dart';
     4        import "package:go_router/go_router.dart";
     5        import 'package:functional_widget_annotation/functional_widget_annotation.dart';
     6        import 'package:gap/gap.dart';
     7        import 'package:sport_changer/presentation/router/routes.dart';
     8        import 'package:sport_changer/application/controllers/exporter.dart';
       
     9        import 'package:sport_changer/application/controllers/auth.dart';
    10        import 'package:sport_changer/domain/auth.dart';
    11        import './personal.dart';
    12        import './admin.dart';
       
    13        part 'main_screen.g.dart';
       
    14        @hcwidget
    15        Widget mainScreen(BuildContext context, WidgetRef ref) {
    16          final authInfo = ref.watch(authInfoControlerProvider);
    17          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    18          return Scaffold(
    19              appBar: AppBar(
    20                title: Text(lang["main_screen"] ?? "Main Screen"),
    21              ),
    22              body: Padding(
    23                padding: const EdgeInsets.all(16),
    24                child: Center(
    25                    child: Column(children: [
    26                  TextButton(
    27                      child: const Text("Go to Auth"),
    28                      onPressed: () =>
    29                          ref.read(authInfoControlerProvider.notifier).deleteToken()),
    30                  authInfo.when(
    31                    data: (value) => value != null
    32                        ? userInfo(context, ref, authInfo: value)
    33                        : const Text("No data"),
    34                    loading: () => const CircularProgressIndicator(),
    35                    error: (error, stack) => Text("Error: $error"),
    36                  ),
    37                  TextButton(
    38                      child: const Text("Go to Exercises"),
    39                      onPressed: () => context.go(Routes.exercise.url)),
    40                ])),
    41              ));
    42        }
       
    43        @hcwidget
    44        Widget shellScreen(BuildContext context, WidgetRef ref,
    45            {required Widget child}) {
    46          final checkedIndex = useState(0);
    47          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    48          return Scaffold(
    49            body: child,
    50            bottomNavigationBar: BottomNavigationBar(
    51              items: [
    52                BottomNavigationBarItem(
    53                  icon: const Icon(Icons.fitness_center),
    54                  label: lang["panel"] ?? "Panel",
    55                ),
    56                BottomNavigationBarItem(
    57                  icon: const Icon(Icons.settings),
    58                  label: lang["settings"] ?? "Settings",
    59                ),
    60              ],
    61              currentIndex: checkedIndex.value,
    62              onTap: (index) {
    63                checkedIndex.value = index;
    64                if (index == 0) {
    65                  context.go(Routes.exercise.url);
    66                } else {
    67                  context.go(Routes.settings.url);
    68                }
    69              },
    70            ),
    71          );
    72        }
       
    73        @hcwidget
    74        Widget userInfo(BuildContext context, WidgetRef ref,
    75            {required AuthInfo authInfo}) {
    76          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    77          return Column(
    78            crossAxisAlignment: CrossAxisAlignment.start,
    79            children: [
    80              Text("${lang["email"] ?? "Email"}: ${authInfo.email}"),
    81              Text("${lang["name"] ?? "Name"}: ${authInfo.name}"),
    82              Text("${lang["surname"] ?? "Surname"}: ${authInfo.surname}"),
    83              Text(
    84                  "${lang["login_type"] ?? "Login type"}: ${authInfo.loginType?.name}"),
    85              Text(
    86                  "${lang["login_variants"] ?? "Login variants"}: ${authInfo.loginVariants.map((l) => l.name).join(", ")}"),
    87            ],
    88          );
    89        }
       
    90        @hcwidget
    91        Widget settingScreen(BuildContext context, WidgetRef ref) {
    92          final authInfo = ref.watch(authInfoControlerProvider);
    93          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    94          return Scaffold(
    95            appBar: AppBar(
    96              title: Text(lang["settings"] ?? "Settings"),
    97              actions: [
    98                IconButton(
    99                    onPressed: () {
   100                      ref.read(authInfoControlerProvider.notifier).deleteToken();
   101                    },
   102                    icon: const Icon(Icons.logout))
   103              ],
   104            ),
   105            body: Padding(
   106              padding: const EdgeInsets.all(16),
   107              child: Column(
   108                crossAxisAlignment: CrossAxisAlignment.start,
   109                children: [
   110                  authInfo.when(
   111                      data: (value) => value == null
   112                          ? const Text("Wait")
   113                          : UserInfo(authInfo: value),
   114                      loading: () => const CircularProgressIndicator(),
   115                      error: (error, stack) =>
   116                          Text("${lang["error"] ?? "Error"} $error")),
   117                  const Gap(32),
   118                  Row(mainAxisAlignment: MainAxisAlignment.spaceAround, children: [
   119                    TextButton(
   120                      onPressed: () {
   121                        ref.read(authInfoControlerProvider.notifier).changeUserType();
   122                      },
   123                      child: Text(lang["change_user_type"] ?? "Change user type"),
   124                    ),
   125                    const LangChanger()
   126                  ]),
   127                  TextButton(
   128                      onPressed: () {
   129                        authInfo.when(
   130                            data: (value) {
   131                              if (value != null) {
   132                                exportData(value.toJson().toString());
   133                              }
   134                            },
   135                            loading: () {},
   136                            error: (error, stack) {});
   137                      },
   138                      child: Text(lang["export"] ?? "Export")),
   139                ],
   140              ),
   141            ),
   142          );
   143        }
       
   144        @hcwidget
   145        Widget langChanger(BuildContext context, WidgetRef ref) {
   146          final lang = ref.watch(languageSettingProvider);
       
   147          return DropdownMenu(
   148              initialSelection: lang,
   149              onSelected: (value) {
   150                ref.read(languageSettingProvider.notifier).setLang(value ?? "en");
   151              },
   152              dropdownMenuEntries: const [
   153                DropdownMenuEntry(label: "English", value: "en"),
   154                DropdownMenuEntry(label: "Ukrainian", value: "ua")
   155              ],
   156              label: const Text("Language"));
   157        }
       
   158        @hcwidget
   159        Widget multiScreen(BuildContext context, WidgetRef ref) {
   160          final userType = ref.watch(getLoginTypeProvider);
   161          return userType == LoginType.personal
   162              ? const ClientViewScreen()
   163              : const AdminMainScreen();
   164        }
В.4 Код екрану персоналу
     1        import "package:flutter/material.dart";
     2        import "package:hooks_riverpod/hooks_riverpod.dart";
     3        import 'package:go_router/go_router.dart';
     4        import 'package:functional_widget_annotation/functional_widget_annotation.dart';
     5        import 'package:sport_changer/application/controllers/personal.dart';
     6        import 'package:flutter_hooks/flutter_hooks.dart';
     7        import 'package:sport_changer/presentation/router/routes.dart';
     8        import 'package:sport_changer/application/controllers/auth.dart';
     9        import 'package:sport_changer/domain/auth.dart';
    10        import './personal.dart';
    11        import './admin.dart';
       
    12        part 'personal.g.dart';
       
    13        @hcwidget
    14        Widget clientViewScreen(BuildContext context, WidgetRef ref) {
    15          final clients = ref.watch(clientControllerProvider);
    16          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    17          return Scaffold(
    18              appBar: AppBar(
    19                title: Text(lang["personal_screen"] ?? "Personal Screen"),
    20              ),
    21              floatingActionButton: FloatingActionButton(
    22                onPressed: () {
    23                  ref.read(clientControllerProvider.notifier).updateClients();
    24                },
    25                child: const Icon(Icons.refresh),
    26              ),
    27              body: Center(
    28                child: clients.when(
    29                    data: (clients) => ListView.builder(
    30                        itemCount: clients.length,
    31                        itemBuilder: (context, index) {
    32                          final client = clients[index];
    33                          return ListTile(
    34                            title: Text(client.name ?? "No name"),
    35                            subtitle: Text(
    36                                client.surname ?? lang["no_surname"] ?? "No surname"),
    37                            onTap: () {
    38                              context.push(Routes.client.url
    39                                  .replaceFirst(":id", client.id.toString()));
    40                            },
    41                          );
    42                        }),
    43                    loading: () => const CircularProgressIndicator(),
    44                    error: (error, stack) => Text("Error: $error")),
    45              ));
    46        }
       
    47        @hcwidget
    48        Widget clientScreen(BuildContext context, WidgetRef ref, {required int id}) {
    49          final client = ref.watch(clientControllerProvider.select((value) => value
    50              .whenData((value) => value.firstWhere((element) => element.id == id))));
       
    51          ref.read(clientControllerProvider.notifier).getClientExercises(id);
    52          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
    53          return Scaffold(
    54            appBar: AppBar(
    55              title: Text(lang["client_screen"] ?? "Client Screen"),
    56            ),
    57            floatingActionButton: FloatingActionButton(
    58              onPressed: () {
    59                context.pushNamed("addExercise", pathParameters: {"id": id.toString()});
    60              },
    61              child: const Icon(Icons.add),
    62            ),
    63            body: Center(
    64                child: client.when(
    65              data: (client) {
    66                final name = client.name ?? lang["no_name"] ?? "No name";
    67                final surname = client.surname ?? lang["no_surname"] ?? "No surname";
    68                return ListView(
    69                  padding: const EdgeInsets.symmetric(horizontal: 16),
    70                  children: [
    71                    Text("${lang["name"] ?? "Name"}: $name"),
    72                    Text("${lang["surname"] ?? "Surname"}: $surname"),
    73                    ...client.exercises.where((e) => e.exercise != null).map((e) {
    74                      final duration = e.duration == const Duration()
    75                          ? lang["not_started"] ?? "Not started"
    76                          : "${lang["duration"] ?? "Duration"}: ${e.duration}";
    77                      final exerciseTypesName = ref.watch(
    78                          getExerciseTypeNameProvider(id: e.exercise!.exerciseTypeId!));
    79                      final title = "${e.exercise!.name} [$exerciseTypesName]";
    80                      return ListTile(
    81                        title: ListTile(
    82                            title: Text(title),
    83                            subtitle: Text(
    84                                "$duration, ${lang["measurement"] ?? "Measurement"}: ${e.exercise!.measurement}")),
    85                      );
    86                    })
    87                  ],
    88                );
    89              },
    90              loading: () => const CircularProgressIndicator(),
    91              error: (error, stack) => Text("Error: $error"),
    92            )),
    93          );
    94        }
       
    95        @hcwidget
    96        Widget newExerciseScreen(BuildContext context, WidgetRef ref,
    97            {required int id}) {
    98          final exercises = ref.watch(getExercisesProvider);
    99          final lang = languages[ref.watch(languageSettingProvider)] ?? {};
       
   100          return Scaffold(
   101              appBar: AppBar(
   102                title: Text(lang["choose_exercise"] ?? "Choose Exercise"),
   103              ),
   104              body: Padding(
   105                padding: const EdgeInsets.all(16),
   106                child: Center(
   107                    child: exercises.when(
   108                  loading: () => const CircularProgressIndicator(),
   109                  error: (error, _) => Text("Error: $error"),
   110                  data: (data) => ListView.separated(
   111                    itemCount: data.length,
   112                    separatorBuilder: (BuildContext context, int index) {
   113                      return const Divider();
   114                    },
   115                    itemBuilder: (BuildContext context, int index) {
   116                      return TextButton(
   117                          child: Text(data[index].name),
   118                          onPressed: () {
   119                            ref
   120                                .read(clientControllerProvider.notifier)
   121                                .addExercise(id, data[index].id!);
   122                            context.pop();
   123                          });
   124                    },
   125                  ),
   126                )),
   127              ));
   128        }










________________


Додаток Д Програмний код мобільної частини
Д.1 Код екранів користувача
     1        package com.nicourrrn.sportchanger.ui.screens
       
     2        import androidx.compose.foundation.layout.Arrangement
     3        import androidx.compose.foundation.layout.Column
     4        import androidx.compose.foundation.layout.fillMaxSize
     5        import androidx.compose.foundation.layout.padding
     6        import androidx.compose.material3.*
     7        import androidx.compose.material.icons.Icons
     8        import androidx.compose.material.icons.filled.AccountCircle
     9        import androidx.compose.material.icons.filled.CheckCircle
    10        import androidx.compose.material3.BottomAppBar
    11        import androidx.compose.runtime.Composable
    12        import androidx.compose.runtime.SideEffect
    13        import androidx.compose.runtime.mutableStateOf
    14        import androidx.compose.runtime.remember
    15        import androidx.compose.ui.Alignment
    16        import androidx.compose.ui.Modifier
    17        import androidx.navigation.NavController
    18        import androidx.navigation.Navigation.findNavController
    19        import com.nicourrrn.sportchanger.application.AuthenticationViewModel
    20        import org.koin.androidx.compose.koinViewModel
       
    21        enum class AuthType {
    22            Login, Registration
    23        }
       
    24        @Composable
    25        fun AuthorizationScreen(viewModel: AuthenticationViewModel = koinViewModel()) {
    26            var screen = remember { mutableStateOf(AuthType.Login) }
       
    27            SideEffect {
    28                viewModel.findToken()
    29            }
       
    30            Scaffold(
    31                bottomBar = {
    32                    NavigationBar {
    33                        NavigationBarItem(selected = screen.value == AuthType.Login, onClick = { screen.value = AuthType.Login },
    34                            icon = { Icon(Icons.Filled.CheckCircle, "Login") })
    35                        NavigationBarItem(selected = screen.value == AuthType.Registration, onClick = { screen.value = AuthType.Registration },
    36                            icon = { Icon(Icons.Filled.AccountCircle, "Registration") })
    37                    }
    38                }
    39            ) {padding ->
    40                val modifier = Modifier
    41                    .padding(padding)
    42                    .fillMaxSize()
    43                if (screen.value == AuthType.Login)
    44                    LoginScreen(modifier, viewModel)
    45                else RegistrationScreen(modifier, viewModel)
       
    46                }
    47        }
       
    48        @Composable
    49        fun LoginScreen(modifier: Modifier, viewModel: AuthenticationViewModel = koinViewModel()) {
    50            Column(modifier, horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center) {
    51                TextField(value = viewModel.user.value.email,
    52                    onValueChange = { viewModel.updateUserMain(email = it) },
    53                    label = { Text("Email") })
    54                TextField(value = viewModel.user.value.password ?: ""  ,
    55                    onValueChange = {viewModel.updateUserMain(password = it)},
    56                    label = { Text("Password") })
    57                TextButton(onClick = { viewModel.login() }) {
    58                    Text("Log in")
    59                }
    60            }
    61        }
       
    62        @Composable
    63        fun RegistrationScreen(modifier: Modifier, viewModel: AuthenticationViewModel = koinViewModel()) {
    64            Column(modifier, horizontalAlignment = Alignment.CenterHorizontally, verticalArrangement = Arrangement.Center) {
    65                TextField(value = viewModel.user.value.email,
    66                    onValueChange = { viewModel.updateUserMain(email = it) },
    67                    label = { Text("Email") })
    68                TextField(value = viewModel.user.value.name ?: "",
    69                    onValueChange = {viewModel.updateUserAdditional(name = it)}, label = { Text("Name") })
    70                TextField(value = viewModel.user.value.surname ?: "",
    71                    onValueChange = {viewModel.updateUserAdditional(surname = it)}, label = { Text("Surname") })
    72                TextField(value = viewModel.user.value.password ?: ""  ,
    73                    onValueChange = {viewModel.updateUserMain(password = it)},
    74                    label = { Text("Password") })
    75                TextButton(onClick = { viewModel.registration() }) {
    76                    Text("Registration")
    77                }
    78            }
    79        }package com.nicourrrn.sportchanger.ui.screens
       
    80        import androidx.compose.foundation.layout.Column
    81        import androidx.compose.foundation.layout.Row
    82        import androidx.compose.foundation.layout.padding
    83        import androidx.compose.foundation.rememberScrollState
    84        import androidx.compose.foundation.verticalScroll
    85        import androidx.compose.material.icons.Icons
    86        import androidx.compose.material.icons.filled.AccountCircle
    87        import androidx.compose.material.icons.filled.Done
    88        import androidx.compose.material.icons.filled.Settings
    89        import androidx.compose.material.icons.outlined.Refresh
    90        import androidx.compose.material3.*
    91        import androidx.compose.runtime.Composable
    92        import androidx.compose.runtime.SideEffect
    93        import androidx.compose.runtime.mutableStateOf
    94        import androidx.compose.runtime.remember
    95        import androidx.compose.ui.Modifier
    96        import com.nicourrrn.sportchanger.application.AuthenticationViewModel
    97        import com.nicourrrn.sportchanger.application.ExerciseViewModel
    98        import org.koin.androidx.compose.koinViewModel
    99        import kotlin.time.Duration
   100        import kotlin.time.DurationUnit
   101        import kotlin.time.toDuration
       
   102        enum class ScreenType {
   103            Setting, Exercises
   104        }
       
   105        @OptIn(ExperimentalMaterial3Api::class)
   106        @Composable
   107        fun UserScreen(userViewModel: AuthenticationViewModel = koinViewModel(), exerciseViewModel: ExerciseViewModel = koinViewModel()) {
   108            SideEffect {
   109                userViewModel.getUserInfo()
   110                exerciseViewModel.init()
   111            }
       
   112            val screen = remember {mutableStateOf(ScreenType.Exercises)}
       
   113            Scaffold(
   114                topBar = {
   115                         TopAppBar(title = { Text(if (screen.value == ScreenType.Exercises) "Exercises" else "Settings") })
   116                },
   117                bottomBar = {
   118                    NavigationBar {
   119                        NavigationBarItem(selected = screen.value == ScreenType.Exercises, onClick = { screen.value = ScreenType.Exercises },
   120                            icon = { Icon(Icons.Filled.Done, "Exercise") })
   121                        NavigationBarItem(selected = screen.value == ScreenType.Setting, onClick = { screen.value = ScreenType.Setting },
   122                            icon = { Icon(Icons.Filled.Settings, "Settings") })
   123                    }
   124                },
   125                floatingActionButton = { FloatingActionButton(onClick = { if(screen.value == ScreenType.Exercises) exerciseViewModel.init() else userViewModel.getUserInfo() }) {
   126                    Icon(Icons.Outlined.Refresh, "Update")
   127                } }
       
   128            ) {padding ->
   129                val modifier = Modifier.padding(padding)
   130                if (screen.value == ScreenType.Exercises) ExerciseScreen(
   131                    modifier = modifier,
   132                    exerciseViewModel = exerciseViewModel,
   133                    userViewModel = userViewModel
   134                ) else SettingScreen(modifier = modifier,
   135                    userViewModel = userViewModel,
   136                    exerciseViewModel = exerciseViewModel)
       
   137            }
   138        }
       
   139        @Composable
   140        fun ExerciseScreen(modifier: Modifier, exerciseViewModel: ExerciseViewModel, userViewModel: AuthenticationViewModel) {
   141            Column(modifier = modifier.verticalScroll(rememberScrollState())) {
   142                exerciseViewModel.exercises.value.map {
   143                    val duration = if (it.duration == null) "Not Started" else it.duration.toDuration(DurationUnit.SECONDS)
   144                    ListItem(headlineContent = { Text(
   145                        it.exercise.name +
   146                                " [${it.exercise.measurement}]" +
   147                                " of ${exerciseViewModel.exerciseType.value[it.exercise.exerciseTypeId]} type")
   148                    }, supportingContent = { Text("$duration") }, trailingContent = { if (exerciseViewModel.nextExerciseId.value == it.id) Text("Changed") else TextButton(
   149                        onClick = { exerciseViewModel.newNextExercise(it.id ?: 0) }) {
   150                         Text("Change")
   151                    } })
   152                }
   153            }
   154        }
       
   155        @Composable
   156        fun SettingScreen(modifier: Modifier, userViewModel: AuthenticationViewModel, exerciseViewModel: ExerciseViewModel) {
   157            
   158            val iotId = remember {
   159                mutableStateOf("")
   160            }
   161            Column(modifier) {
   162                Text("Name: ${userViewModel.user.value.name}")
   163                Text("Have IoT: ${if (userViewModel.userHaveIot.value) "have" else "have not"}")
   164                TextButton(onClick = { userViewModel.logOut() }) {
   165                    Text("Log Out")
   166                }
   167                Row { 
   168                    OutlinedTextField(value = iotId.value, onValueChange = { iotId.value = it })
   169                    OutlinedButton(onClick = { exerciseViewModel.makePair(iotId.value.toInt()) }) {
   170                        Text("Pair")
   171                    }
   172                }
   173            }
   174        }
Д.2 Код класів управління станами екранів


     1        package com.nicourrrn.sportchanger.application
       
     2        import android.content.Context
     3        import android.widget.TabHost
     4        import androidx.core.content.edit
     5        import com.nicourrrn.sportchanger.domain.Exercise
     6        import com.nicourrrn.sportchanger.domain.ExerciseRepository
     7        import com.nicourrrn.sportchanger.domain.ExerciseType
     8        import com.nicourrrn.sportchanger.domain.ExerciseUser
     9        import com.nicourrrn.sportchanger.domain.Id
    10        import com.nicourrrn.sportchanger.domain.User
    11        import com.nicourrrn.sportchanger.domain.UserIotPair
    12        import com.nicourrrn.sportchanger.domain.UserRepository
    13        import com.nicourrrn.sportchanger.domain.emptyUser
    14        import com.nicourrrn.sportchanger.domain.prefStoreKey
    15        import com.nicourrrn.sportchanger.domain.url
    16        import io.ktor.client.HttpClient
    17        import io.ktor.client.call.body
    18        import io.ktor.client.engine.okhttp.OkHttp
    19        import io.ktor.client.plugins.contentnegotiation.ContentNegotiation
    20        import io.ktor.client.plugins.logging.Logging
    21        import io.ktor.client.request.get
    22        import io.ktor.client.request.headers
    23        import io.ktor.client.request.post
    24        import io.ktor.client.request.setBody
    25        import io.ktor.http.ContentType
    26        import io.ktor.http.HttpHeaders
    27        import io.ktor.http.append
    28        import io.ktor.http.contentType
    29        import io.ktor.serialization.kotlinx.json.json
       
       
    30        class UserRepositoryHttp(private val context: Context) : UserRepository {
    31            private val client = HttpClient(OkHttp) {
    32                expectSuccess = true
    33                install(Logging)
    34                install(ContentNegotiation) {
    35                    json()
    36                }
    37            }
       
    38            private val sharedPref = context.getSharedPreferences(prefStoreKey, Context.MODE_PRIVATE)
       
    39            override suspend fun haveIot(): Boolean {
    40                return try {
    41                    val token = getToken() ?: ""
    42                    client.get("$url/api/user/have_iot") {
    43                        headers {
    44                            append(HttpHeaders.Authorization, "Bearer $token")
    45                        }
       
    46                    }.body()
    47                } catch (e: Throwable) {
    48                    println(e)
    49                    false
    50                }
    51            }
       
    52            override fun getToken(): String? {
    53               return sharedPref.getString("token", null)
    54            }
       
    55            override suspend fun userInfo(token: String?): User {
    56                try {
    57                    val finalToken = token ?: getToken()
    58                    println("User token: $finalToken")
    59                    if (finalToken == null) {
    60                        throw Error("Token is null")
    61                    }
    62                    val user: User = client.get("$url/api/auth/user_info") {
    63                        headers {
    64                            append(HttpHeaders.Authorization,  "Bearer $finalToken")
    65                        }
    66                    }.body()
    67                    print("User: ${user.name}")
    68                    return user
    69                } catch (e: Throwable) {
    70                    println(e)
    71                    return emptyUser()
    72                }
       
       
    73            }
    74            override suspend fun setToken(token: String?) {
    75                if (token != null) {
    76                    sharedPref.edit {
    77                        putString("token", token)
    78                        apply()
    79                    }
    80                } else {
    81                    sharedPref.edit {
    82                        this.remove("token")
    83                    }
    84                }
    85            }
    86            override suspend fun logIn(user: User): String? {
    87                try {
    88                    val token: String = client.post("$url/api/auth/log_in") {
    89                        contentType(ContentType.Application.Json)
    90                        setBody(user)
    91                    }.body<String>().drop(1).dropLast(1)
       
    92                    setToken(token)
    93                    return token
    94                } catch (e: Throwable) {
    95                    return null
    96                }
    97            }
       
    98            override suspend fun registration(user: User): String? {
    99                try {
   100                    val token: String = client.post("$url/api/auth/log_in") {
   101                        contentType(ContentType.Application.Json)
   102                        setBody(user)
   103                    }.body<String>().drop(1).dropLast(1)
       
   104                    setToken(token)
   105                    return token
   106                } catch (e: Throwable) {
   107                    return null
   108                }
       
   109            }
   110        }
       
   111        class ExerciseRepositoryHttp(private val userRepository: UserRepository) : ExerciseRepository {
   112            private val client = HttpClient(OkHttp) {
   113                expectSuccess = true
   114                install(Logging)
   115                install(ContentNegotiation) {
   116                    json()
   117                }
   118            }
   119            override suspend fun getExerciseTypes(): Map<Int, String> {
   120                val exerciseTypes: Map<Int, String> = client.get("$url/api/personal/get_exercise_types")
   121                    .body()
       
   122                println(exerciseTypes)
   123                return exerciseTypes
   124            }
       
   125            override suspend fun getUserExercises(): List<ExerciseUser> {
   126                val token = userRepository.getToken()
   127                println("User token from exercise repository: $token")
   128                try {
   129                    val exercises: List<ExerciseUser> = client.get("$url/api/user/get_exercises") {
   130                        headers {
   131                            append(HttpHeaders.Authorization, "Bearer $token")
   132                        }
   133                    }.body()
   134                    return exercises
   135                } catch (e: Throwable) {
   136                    println(e)
   137                    return listOf()
   138                }
   139            }
       
   140            override suspend fun makePair(pair: UserIotPair) {
   141                val token = userRepository.getToken()
   142                try {
   143                    client.post("$url/api/user/give_iot") {
   144                        headers {
   145                            append(HttpHeaders.Authorization, "Bearer $token")
   146                        }
   147                        contentType(ContentType.Application.Json)
   148                        setBody(pair)
   149                    }
   150                } catch (e: Throwable) {
   151                    println(e)
   152                }
   153            }
       
   154            override suspend fun setNextExercise(exerciseUserId: Int) {
   155                val token = userRepository.getToken()
   156                try {
   157                    client.post("$url/api/user/set_exercise_task") {
   158                        headers {
   159                            append(HttpHeaders.Authorization, "Bearer $token")
   160                        }
   161                        contentType(ContentType.Application.Json)
   162                        setBody(Id(id = exerciseUserId))
   163                    }
   164                } catch (e: Throwable) {
   165                    println("Error: $e")
   166                }
   167            }
       
   168            override suspend fun getNextExercise(): Id {
   169                val token = userRepository.getToken()
   170                return try {
   171                    client.get("$url/api/user/get_exercise_task") {
   172                        headers {
   173                            append(HttpHeaders.Authorization, "Bearer $token")
   174                        }
   175                    }.body()
   176                } catch (e: Throwable) {
   177                    println("Error: $e")
   178                    Id(id = -1)
   179                }
   180            }
       
   181        }package com.nicourrrn.sportchanger.application
       
   182        import android.view.View
   183        import androidx.compose.runtime.MutableState
   184        import androidx.compose.runtime.State
   185        import androidx.compose.runtime.mutableStateOf
   186        import androidx.lifecycle.ViewModel
   187        import androidx.lifecycle.viewModelScope
   188        import androidx.navigation.NavController
   189        import com.nicourrrn.sportchanger.domain.ExerciseRepository
   190        import com.nicourrrn.sportchanger.domain.ExerciseType
   191        import com.nicourrrn.sportchanger.domain.ExerciseUser
   192        import com.nicourrrn.sportchanger.domain.User
   193        import com.nicourrrn.sportchanger.domain.UserIotPair
   194        import com.nicourrrn.sportchanger.domain.UserRepository
   195        import com.nicourrrn.sportchanger.domain.emptyUser
   196        import kotlinx.coroutines.launch
   197        import org.koin.androidx.viewmodel.dsl.viewModel
   198        import org.koin.dsl.module
       
   199        class AuthenticationViewModel(private val userRepository: UserRepository) : ViewModel() {
   200            private var _user: MutableState<User> = mutableStateOf(emptyUser())
   201            val user: State<User> = _user
   202            private var _userHaveIot = mutableStateOf(false)
   203            val userHaveIot: State<Boolean> = _userHaveIot
   204            private var _token: MutableState<String?> = mutableStateOf(null)
   205            val token: State<String?> = _token
   206            var navController: MutableState<NavController?> = mutableStateOf(null)
       
   207            fun init(nav: NavController) {
   208                navController.value = nav
   209            }
       
   210            fun updateUserMain(email: String? = null, password: String? = null) {
   211                val u = _user.value
   212                _user.value = u.copy(email = email ?: u.email, password = password ?: u.password)
   213            }
       
   214            fun updateUserAdditional(name: String? = null, surname: String? = null) {
   215                val u = _user.value
   216                _user.value = u.copy(name = name ?: u.name, surname = surname ?: u.surname)
   217            }
       
   218            fun findToken(){
   219                viewModelScope.launch {
   220                    _token.value = userRepository.getToken()
   221                    if (_token.value != null) {
   222                        navController.value?.navigate("/")
   223                    }
   224                }
   225            }
       
   226            fun login() {
   227                viewModelScope.launch {
   228                    _token.value = userRepository.logIn(_user.value)
   229                    if (_token.value != null) {
   230                        navController.value?.navigate("/")
   231                    }
   232                }
   233            }
       
   234            fun registration() {
   235                viewModelScope.launch {
   236                    _token.value = userRepository.registration(_user.value)
   237                    if (_token.value != null) {
   238                        navController.value?.navigate("/")
   239                    }
   240                }
   241            }
       
   242            fun logOut() {
   243                viewModelScope.launch {
   244                    userRepository.setToken(null)
   245                    navController.value?.navigate("/authorization")
   246                }
   247            }
       
   248            fun getUserInfo() {
   249                viewModelScope.launch {
   250                    _user.value = userRepository.userInfo()
   251                    _userHaveIot.value = userRepository.haveIot()
   252                }
   253            }
       
   254        }
       
   255        val userAppModule = module {
   256            single<UserRepository> { UserRepositoryHttp(get()) }
   257            viewModel { AuthenticationViewModel(get()) }
   258        }
       
   259        class ExerciseViewModel(private val exerciseRepository: ExerciseRepository) : ViewModel(){
   260            private var _exerciseTypes: MutableState<Map<Int, String>> = mutableStateOf(mapOf())
   261            val exerciseType: State<Map<Int, String>> = _exerciseTypes
       
   262            private var _exercises: MutableState<List<ExerciseUser>> = mutableStateOf(listOf())
   263            val exercises: State<List<ExerciseUser>> = _exercises
       
   264            private var _nextExerciseId = mutableStateOf(-1)
   265            val nextExerciseId: State<Int> = _nextExerciseId
       
   266            fun init() {
   267                viewModelScope.launch {
   268                    _exerciseTypes.value = exerciseRepository.getExerciseTypes()
   269                    _exercises.value = exerciseRepository.getUserExercises()
   270                    _nextExerciseId.value = exerciseRepository.getNextExercise().id
   271                }
   272            }
       
   273            fun makePair(iotId: Int) {
   274                viewModelScope.launch {
   275                    exerciseRepository.makePair(UserIotPair(iotId = iotId))
   276                }
   277            }
       
   278            fun newNextExercise(exerciseId: Int) {
   279                viewModelScope.launch {
   280                    exerciseRepository.setNextExercise(exerciseId)
   281                    _nextExerciseId.value = exerciseId
   282                }
   283            }
       
       
       
   284        }
       
   285        val exerciseAppModule = module {
   286            single<ExerciseRepository> { ExerciseRepositoryHttp(get()) }
   287            viewModel { ExerciseViewModel(get()) }
   288        }


________________


Додаток Е Перевірка на академічної доброчесність
  

Рис. Е.1 – знімок з екрана результату перевірки.